var documenterSearchIndex = {"docs":
[{"location":"manual/examples/#man-examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"note: Note\nMore examples coming soon, for now please refer to the Juice Examples Repository","category":"page"},{"location":"api/internals/utils/#api-internal-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/internals/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/internals/utils/#LogicCircuits.Utils","page":"Utils","title":"LogicCircuits.Utils","text":"Module with general utilities and missing standard library features  that could be useful in any Julia project\n\n\n\n\n\n","category":"module"},{"location":"api/internals/utils/#LogicCircuits.Utils.Dag","page":"Utils","title":"LogicCircuits.Utils.Dag","text":"A node in a directed acyclic graph (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Downpass","page":"Utils","title":"LogicCircuits.Utils.Downpass","text":"Compute a function top down on the circuit. f_root is called on the root node, f_leaf is called on leaf nodes, and f_inner  is called on inner nodes. Values of type T are passed down the circuit and given to f_inner as a value from the parent.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Inner","page":"Utils","title":"LogicCircuits.Utils.Inner","text":"The trait of inner nodes (nodes that have children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Leaf","page":"Utils","title":"LogicCircuits.Utils.Leaf","text":"The trait of leaf nodes (nodes without children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Lit","page":"Utils","title":"LogicCircuits.Utils.Lit","text":"Literals are represented as 32-bit signed integers. Positive literals are positive integers identical to their variable. Negative literals are their negations. Integer 0 should not be used to represent literals.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Node","page":"Utils","title":"LogicCircuits.Utils.Node","text":"A node in a directed graph. This type hierarchy is organized according  to the type of graph the node is part of.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"A trait hierarchy denoting types of Dag nodes NodeType defines an orthogonal type hierarchy of node types, so we can dispatch on node type regardless of the graph type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"Get the node type trait of the given Node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.Tree","page":"Utils","title":"LogicCircuits.Utils.Tree","text":"A node in a tree (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Var","page":"Utils","title":"LogicCircuits.Utils.Var","text":"Variables are represented as 32-bit unsigned integers\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#Base.filter-Union{Tuple{T}, Tuple{Function,Dag}, Tuple{Function,Dag,Type{T}}} where T","page":"Utils","title":"Base.filter","text":"Retrieve list of nodes in graph matching predicate p\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.foreach-Tuple{Function,Dag}","page":"Utils","title":"Base.foreach","text":"Apply a function to each node in a graph, bottom up\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.in-Tuple{Dag,Dag}","page":"Utils","title":"Base.in","text":"Is the node contained in the Dag?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.isdisjoint-Tuple{AbstractSet,AbstractSet,AbstractSet,Vararg{AbstractSet,N} where N}","page":"Utils","title":"Base.isdisjoint","text":"Are the given sets disjoint (no shared elements)?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.parent","page":"Utils","title":"Base.parent","text":"Get the parent of a given tree node (or nothing if the node is root)\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#DataFrames.groupby-Union{Tuple{E}, Tuple{Function,Union{Set{E}, Array{E,1}}}} where E","page":"Utils","title":"DataFrames.groupby","text":"Group the elements of list by their values according to function f\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.always-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.always","text":"An array of 100% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.bits_per_pixel-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.bits_per_pixel","text":"Normalize the given log-likelihood as bits per pixel in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.children","page":"Utils","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.example-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.example","text":"Get the ith example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.feature_values-Tuple{DataFrames.DataFrame,Any}","page":"Utils","title":"LogicCircuits.Utils.feature_values","text":"Get the ith feature values\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.flip_bit-Union{Tuple{Dag}, Tuple{Bit}, Tuple{Dag,Val{Bit}}} where Bit","page":"Utils","title":"LogicCircuits.Utils.flip_bit","text":"Flip the bit field throughout this graph (or ensure it is set to given value)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{Dag,Function,Function,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup","text":"Compute a function bottom-up on the graph.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup_rec-Union{Tuple{Bit}, Tuple{T}, Tuple{Dag,Function,Function,Type{T}}, Tuple{Dag,Function,Function,Type{T},Val{Bit}}} where Bit where T","page":"Utils","title":"LogicCircuits.Utils.foldup_rec","text":"Compute a function bottom-up on the graph, flipping the node bits.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_rec-Union{Tuple{Bit}, Tuple{Function,Dag}, Tuple{Function,Dag,Val{Bit}}} where Bit","page":"Utils","title":"LogicCircuits.Utils.foreach_rec","text":"Apply a function to each node in a graph, bottom up, flipping the node bits\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.fully_factorized_log_likelihood-Tuple{AbstractArray{var\"#s12\",2} where var\"#s12\"<:Bool}","page":"Utils","title":"LogicCircuits.Utils.fully_factorized_log_likelihood","text":"Computer the per-example log-likelihood of a fully factorized ML model on Bool data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.has_children","text":"Does the node have children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_parent-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.has_parent","text":"Does the node have a parent?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.init_array-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.init_array","text":"An array of undetermined values (fast) for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.innernodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.innernodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inode_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.inode_stats","text":"Give count of types and fan-ins of inner nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.inodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isbinarydata-Tuple{AbstractArray{T,2} where T}","page":"Utils","title":"LogicCircuits.Utils.isbinarydata","text":"Is the dataset binary?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isequal_local-Tuple{Tree,Tree}","page":"Utils","title":"LogicCircuits.Utils.isequal_local","text":"Is one node equal to another locally, ignoring children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isinner-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isinner","text":"Is the node an Inner node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isleaf-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isleaf","text":"Is the node a leaf node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isnumericdata-Tuple{AbstractArray{T,2} where T}","page":"Utils","title":"LogicCircuits.Utils.isnumericdata","text":"Is the dataset numeric?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isroot-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.isroot","text":"Is the node the root of its tree?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.issomething-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.issomething","text":"Is the argument not nothing?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lca-Tuple{Tree,Tree,Function}","page":"Utils","title":"LogicCircuits.Utils.lca","text":"Find the least common ancestor. Assumes the Tree has access to a parent.  A given descends_from function is required to quickly check whether a node is an ancestor.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leaf_stats-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.leaf_stats","text":"Give count of types of leaf nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leafnodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.leafnodes","text":"Get the list of leaf nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.left_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.left_most_descendent","text":"Return the left-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.linearize-Union{Tuple{Dag}, Tuple{T}, Tuple{Dag,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.linearize","text":"Order the Dag's nodes bottom-up in a list (with optional element type)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lit2var-Tuple{Int32}","page":"Utils","title":"LogicCircuits.Utils.lit2var","text":"Convert a literal its variable, removing the sign of the literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.ll_per_example-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.ll_per_example","text":"Normalize the given log-likelihood by the number of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.map_values-Union{Tuple{K}, Tuple{Function,AbstractDict{K,V} where V,Type}} where K","page":"Utils","title":"LogicCircuits.Utils.map_values","text":"Map the values in the dictionary, retaining the same keys\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.never-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.never","text":"An array of 0% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.node_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.node_stats","text":"Give count of types and fan-ins of all nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.noop-Tuple","page":"Utils","title":"LogicCircuits.Utils.noop","text":"Function that does nothing\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.num_children","text":"Get the number of children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_edges-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_edges","text":"Number of edges in the Dag\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_examples-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_examples","text":"Number of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_features-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_features","text":"Number of features in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_nodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_nodes","text":"Number of nodes in the Dag\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_variables-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.num_variables","text":"Number of variables in the data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.order_asc-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.order_asc","text":"Order the arguments in a tuple in ascending order\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.pushrand!-Tuple{AbstractArray{var\"#s13\",1} where var\"#s13\",Any}","page":"Utils","title":"LogicCircuits.Utils.pushrand!","text":"Push element into random position in vectorv\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.right_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.right_most_descendent","text":"Return the right-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.shuffle_examples-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.shuffle_examples","text":"Shuffle the examples in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.threshold-Tuple{Any,Any,Any}","page":"Utils","title":"LogicCircuits.Utils.threshold","text":"Threshold a numeric dataset making it binary\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_edges-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.tree_num_edges","text":"Compute the number of edges in of a tree-unfolding of the Dag. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_nodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.tree_num_nodes","text":"Compute the number of nodes in of a tree-unfolding of the Dag. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.uniform-Tuple{Vararg{Int64,N} where N}","page":"Utils","title":"LogicCircuits.Utils.uniform","text":"An array of uniform probabilities\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.var2lit-Tuple{UInt32}","page":"Utils","title":"LogicCircuits.Utils.var2lit","text":"Convert a variable to the corresponding positive literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.variables","page":"Utils","title":"LogicCircuits.Utils.variables","text":"Get the BitSet of variables in the data structure\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.varsubset-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.varsubset","text":"Do the variables in n containing the variables in m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#StatsFuns.logsumexp-Tuple{AbstractArray,Any}","page":"Utils","title":"StatsFuns.logsumexp","text":"Marginalize out dimensions dims from log-probability tensor\n\n\n\n\n\n","category":"method"},{"location":"manual/properties/#man-structural-properties","page":"Structural Properties","title":"Structural Properties","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"note: Note\nThis page is still under construction. For suggestions and fixes, please click on the \"Edit on Github\" button in the top right.","category":"page"},{"location":"manual/properties/#Smoothness","page":"Structural Properties","title":"Smoothness","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/properties/#Determinism","page":"Structural Properties","title":"Determinism","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is deterministic if each of its OR nodes are deterministic.  An OR node is deterministic if for every possible assignment to the variables, at most one of the its children can be active (true).","category":"page"},{"location":"manual/properties/#Decomposability","page":"Structural Properties","title":"Decomposability","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is decomposable if each of its AND nodes are decomposable.  An AND node is decomposable if for each pair of children the set of variables they depend on is disjoint.","category":"page"},{"location":"manual/properties/#Structured-Decomposability","page":"Structural Properties","title":"Structured Decomposability","text":"","category":"section"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"note: Note\nThis page is still under construction. For suggestions and fixes, please click on the \"Edit on Github\" button in the top right.","category":"page"},{"location":"manual/queries/#Evaluation","page":"Queries","title":"Evaluation","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logical circuit Delta and an assignment to its variable, we would like to know the output of the circuit. For example, if Delta = X land Y, and we assign x, lnot y:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"X land Y = texttrue land textfalse = textfalse","category":"page"},{"location":"manual/queries/#Satisfiability","page":"Queries","title":"Satisfiability","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logical circuit Delta, the goal of SAT is to answer whether there is an assignment to its variables such that the output is true. Depending on the structural properties of the logical circuit this problem can be intractable or tractable.","category":"page"},{"location":"manual/queries/#Model-Counting","page":"Queries","title":"Model Counting","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logical circuit Delta, the goal of model counting is to count how many ways there are to assign values to variables of Delta such that the output of the circuit is true. ","category":"page"},{"location":"manual/queries/#Equivalence-Checking","page":"Queries","title":"Equivalence Checking","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given two logical circuits Delta_1 and Delta_2, the goal is to check whether these two circuits represent the same formula. There are both determnistic and probabilistic algorithms for this task.","category":"page"},{"location":"manual/transformations/#man-tranformations","page":"Tranformations","title":"Tranformations","text":"","category":"section"},{"location":"manual/transformations/#Conditioning","page":"Tranformations","title":"Conditioning","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, conditioning on the literal x (resp. lnot x) is equivalent to replacing every occurance of X with true (resp. false). ","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"(Delta mid x)","category":"page"},{"location":"manual/transformations/#Forgetting","page":"Tranformations","title":"Forgetting","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, forgetting the variable X can be thought of as erasing (forgetting) what the formula says about variable X:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta ","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Forgeting is also equivalent to disjunction of different ways to condition on X. The possible values for X are the literals x or lnot x, so we have:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta = (Delta mid x) lor (Delta mid lnot x)","category":"page"},{"location":"manual/transformations/#Smoothing","page":"Tranformations","title":"Smoothing","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Smoothing is the act of converting a non-smooth circuit to a circuit representing the same formula that is smooth. A logical circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/transformations/#Apply","page":"Tranformations","title":"Apply","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given two logical circuits Delta_1, Delta_2, and a binary operation o the apply operation outputs a logical circuit representing:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 o Delta_2","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Note that, in addition to representing the correct formula, the apply operation also wants to preserve the structural properites of the circuits such as  determinism and decomposability.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"The major binary operations are conjunction (land), disjunction (lor), and XOR (oplus). There are 2^4 = 16 possible binary operations, 6 of which are trivial operations (such as always returning false or depending only on one of the circuits). The other 10 can be derived by combination of not operation (lnot) with the main 3 operations mentioned. The list of all possible non-trivial binary operations are below:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor lnot Delta_2 \n    Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land lnot Delta_2 \n    Delta_1 oplus Delta_2 lnot (Delta_1 oplus Delta_2) ","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.3 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-LogicCircuits","page":"Installation","title":"Installing LogicCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"LogicCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package with the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"))'","category":"page"},{"location":"installation/#From-Julia-Pkg-REPL","page":"Installation","title":"From Julia Pkg REPL","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits#master","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"LogicCircuits\")'","category":"page"},{"location":"api/internals/loadsave/#api-internal-io","page":"LoadSave","title":"LoadSave","text":"","category":"section"},{"location":"api/internals/loadsave/","page":"LoadSave","title":"LoadSave","text":"Modules = [LogicCircuits.LoadSave]","category":"page"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.BiasLine","page":"LoadSave","title":"LogicCircuits.LoadSave.BiasLine","text":"A line representing a bias node in the circuit (an OR with one child)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitCommentLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitCommentLine","text":"A string comment line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitFormatLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitFormatLine","text":"A parsed circuit file format line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitFormatLines","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitFormatLines","text":"A file consisting for circuit formal lines\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitHeaderLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitHeaderLine","text":"A header line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.ConstantLine","page":"LoadSave","title":"LogicCircuits.LoadSave.ConstantLine","text":"A line representing either the true or false logical constants\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.DecisionLine","page":"LoadSave","title":"LogicCircuits.LoadSave.DecisionLine","text":"A line representing a decision node in the circuit (an OR of AND elements)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.Element","page":"LoadSave","title":"LogicCircuits.LoadSave.Element","text":"Paired boxes, or elements, are conjunctions  in a larger decision node line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.ID","page":"LoadSave","title":"LogicCircuits.LoadSave.ID","text":"Circuit and vtree node ids used for IO\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.InnerCircuitLine","page":"LoadSave","title":"LogicCircuits.LoadSave.InnerCircuitLine","text":"A circuit format line with child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.LeafCircuitLine","page":"LoadSave","title":"LogicCircuits.LoadSave.LeafCircuitLine","text":"A circuit format line without child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.LiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.LiteralLine","text":"A line that represents a logical literal\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.UnweightedLiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.UnweightedLiteralLine","text":"A line representing a single literal without parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.VtreeAbstractFile","page":"LoadSave","title":"LogicCircuits.LoadSave.VtreeAbstractFile","text":"Used to specify file type .vtree or .dot\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.VtreeFormatLine","page":"LoadSave","title":"LogicCircuits.LoadSave.VtreeFormatLine","text":"A line in the vtree file format\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.WeightedLiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.WeightedLiteralLine","text":"A line representing a weighted single literal (for example a logistic circuit literal).\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.WeightedNamedConstantLine","page":"LoadSave","title":"LogicCircuits.LoadSave.WeightedNamedConstantLine","text":"A weighted constant line for a known variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_logical-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_logical","text":"Compile lines into a unstructured logical circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_logical_m-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_logical_m","text":"Compile lines into a unstructured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_logical-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_logical","text":"Compile lines into a smooth unstructured logical circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_logical_m-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_logical_m","text":"Compile lines into a smooth unstructured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine,AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.VtreeFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical","text":"Compile circuit and vtree lines into a structured logical circuit with its vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical_m-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine,AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.VtreeFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical_m","text":"Compile circuit and vtree lines into a structured logical circuit with its vtree,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical_m-Tuple{AbstractArray{var\"#s89\",1} where var\"#s89\"<:LogicCircuits.LoadSave.CircuitFormatLine,Dict{UInt32,PlainVtree}}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical_m","text":"Compile circuit lines and vtree node mapping into a structured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.decompile-Tuple{PlainStructLiteralNode,Any,Any}","page":"LoadSave","title":"LogicCircuits.LoadSave.decompile","text":"Decompile for sdd circuit, used during saving of circuits to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.get_nodes_level-Tuple{LogicCircuit}","page":"LoadSave","title":"LogicCircuits.LoadSave.get_nodes_level","text":"Rank nodes in the same layer left to right\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_cnf-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_cnf","text":"Load a CNF/DNF as a logical circuit from file. Suppported file formats:\n\n\".cnf\" for CNF files\n\".dnf\" for DNF files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_logic_circuit-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_logic_circuit","text":"Load a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_smooth_logic_circuit-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_smooth_logic_circuit","text":"Load a smooth logical circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_struct_smooth_logic_circuit-Tuple{String,String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_struct_smooth_logic_circuit","text":"Load a smooth structured logical circuit from file. Support circuit file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\nSupported vtree file formats:\n\n\".vtree\" for Vtree files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_dot-Tuple{LogicCircuit,String}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_dot","text":"Save logic circuit to .dot file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_sdd-Tuple{String,StructLogicCircuit,PlainVtree}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_sdd","text":"Save a SDD circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_circuit-Tuple{String,StructLogicCircuit,PlainVtree}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_circuit","text":"Save a circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_vtree-Tuple{PlainVtree,AbstractString}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_vtree","text":"Saves a vtree in the given file path.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.sdd_header-Tuple{}","page":"LoadSave","title":"LogicCircuits.LoadSave.sdd_header","text":"Returns header for SDD file format\n\n\n\n\n\n","category":"method"},{"location":"#LogicCircuits.jl","page":"Home","title":"LogicCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LogicCircuits.jl module provides a Julia implementation of tools to represent boolean formulas, operate on them, and ask queries about them.    ","category":"page"},{"location":"#What-are-Logic-Circuits?","page":"Home","title":"What are Logic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each logical circuit represents a boolean formula.  Internally, they are structured as a DAG with leave nodes being constants (true, false) or literals (X, lnot X).  Internal nodes can be AND or OR nodes.  Note that negation can only be done at the leaves.  This representation of boolean formulas is also known as Negation Normal Form (NNF).  In general, we also want to enforce few other structural properties such as smoothness, determinism, decomposability to enable tractable logical reasoning. ","category":"page"},{"location":"#What-can-we-do-with-them?","page":"Home","title":"What can we do with them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given a logical circuit there are many questions that we can ask.  For example, we might want to see whether it is satisfiable (SAT),  how many different ways are there to satisfy it (model counting),  or check whether it is equivalent with another logical circuit.  We refer to these as queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On another front, we might want to operate on the logical circuits themselves.  For example, we might want to condition on a literal, forget a variable, conjoin or disjoin two circuits, or negate the circuit.  We refer to these tasks as transformations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, many of these tasks are intractable, however given different combinations of  properties on structure of logical circuits we can unlock different queries to become tractable.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the Manual section for more details on important concepts, and examples on how to use this module.","category":"page"},{"location":"api/internals/logiccircuits/#api-internal-logical","page":"Logic","title":"Logic","text":"","category":"section"},{"location":"api/internals/logiccircuits/","page":"Logic","title":"Logic","text":"Modules = [LogicCircuits]","category":"page"},{"location":"api/internals/logiccircuits/#LogicCircuits.structfalse","page":"Logic","title":"LogicCircuits.structfalse","text":"The unique splain tructured logical false constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.structtrue","page":"Logic","title":"LogicCircuits.structtrue","text":"The unique plain structured logical true constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.trimfalse","page":"Logic","title":"LogicCircuits.trimfalse","text":"Canonical trimmed SDD false node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.trimtrue","page":"Logic","title":"LogicCircuits.trimtrue","text":"Canonical trimmed SDD true node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.ApplyCache","page":"Logic","title":"LogicCircuits.ApplyCache","text":"Apply cache for the result of conjunctions and disjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.ConstantGate","page":"Logic","title":"LogicCircuits.ConstantGate","text":"A trait denoting constant leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Element","page":"Logic","title":"LogicCircuits.Element","text":"Represents elements that are not yet compiled into conjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType","page":"Logic","title":"LogicCircuits.GateType","text":"A trait hierarchy denoting types of nodes GateType defines an orthogonal type hierarchy of node types, not circuit types, so we can dispatch on node type regardless of circuit type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.GateType","text":"Get the gate type trait of the given LogicCircuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.InnerGate","page":"Logic","title":"LogicCircuits.InnerGate","text":"A logical gate that is an inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LeafGate","page":"Logic","title":"LogicCircuits.LeafGate","text":"A logical gate that is a leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LiteralGate","page":"Logic","title":"LogicCircuits.LiteralGate","text":"A trait denoting literal leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LogicCircuit","page":"Logic","title":"LogicCircuits.LogicCircuit","text":"Root of the logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainConstantNode","page":"Logic","title":"LogicCircuits.PlainConstantNode","text":"A plain logical constant leaf node, representing true or false\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainFalseNode","page":"Logic","title":"LogicCircuits.PlainFalseNode","text":"Plain constant false node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLiteralNode","page":"Logic","title":"LogicCircuits.PlainLiteralNode","text":"A plain logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicCircuit","page":"Logic","title":"LogicCircuits.PlainLogicCircuit","text":"Root of the plain logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicInnerNode","page":"Logic","title":"LogicCircuits.PlainLogicInnerNode","text":"A plain logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicLeafNode","page":"Logic","title":"LogicCircuits.PlainLogicLeafNode","text":"A plain logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructConstantNode","page":"Logic","title":"LogicCircuits.PlainStructConstantNode","text":"A plain structured logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructFalseNode","page":"Logic","title":"LogicCircuits.PlainStructFalseNode","text":"A plain structured logical false constant.  Never construct one, use structfalse to access its unique instance\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLiteralNode","page":"Logic","title":"LogicCircuits.PlainStructLiteralNode","text":"A plain structured logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicCircuit","page":"Logic","title":"LogicCircuits.PlainStructLogicCircuit","text":"Root of the plain structure logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicInnerNode","page":"Logic","title":"LogicCircuits.PlainStructLogicInnerNode","text":"A plain structured logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicLeafNode","page":"Logic","title":"LogicCircuits.PlainStructLogicLeafNode","text":"A plain structured logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructTrueNode","page":"Logic","title":"LogicCircuits.PlainStructTrueNode","text":"A plain structured logical true constant. Never construct one, use structtrue to access its unique instance\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋀Node","page":"Logic","title":"LogicCircuits.PlainStruct⋀Node","text":"A plain structured logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋁Node","page":"Logic","title":"LogicCircuits.PlainStruct⋁Node","text":"A plain structured logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainTrueNode","page":"Logic","title":"LogicCircuits.PlainTrueNode","text":"Plain constant true node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainVtree","page":"Logic","title":"LogicCircuits.PlainVtree","text":"Root of the plain vtree node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋀Node","page":"Logic","title":"LogicCircuits.Plain⋀Node","text":"A plain logical conjunction node (And node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋁Node","page":"Logic","title":"LogicCircuits.Plain⋁Node","text":"A plain logical disjunction node (Or node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd","page":"Logic","title":"LogicCircuits.Sdd","text":"Root of the SDD circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddConstantNode","page":"Logic","title":"LogicCircuits.SddConstantNode","text":"A SDD logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddFalseNode","page":"Logic","title":"LogicCircuits.SddFalseNode","text":"A SDD logical false constant.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddInnerNode","page":"Logic","title":"LogicCircuits.SddInnerNode","text":"A SDD logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLeafNode","page":"Logic","title":"LogicCircuits.SddLeafNode","text":"A SDD logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLiteralNode","page":"Logic","title":"LogicCircuits.SddLiteralNode","text":"A SDD logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgr","page":"Logic","title":"LogicCircuits.SddMgr","text":"Root of the SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddTrueNode","page":"Logic","title":"LogicCircuits.SddTrueNode","text":"A SDD logical true constant.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋀Node","page":"Logic","title":"LogicCircuits.Sdd⋀Node","text":"A SDD logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋁Node","page":"Logic","title":"LogicCircuits.Sdd⋁Node","text":"A SDD logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.StructLogicCircuit","page":"Logic","title":"LogicCircuits.StructLogicCircuit","text":"Root of the structure logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.TrimSddMgr","page":"Logic","title":"LogicCircuits.TrimSddMgr","text":"Root of the trimmed SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.TrimSddMgrInnerNode","page":"Logic","title":"LogicCircuits.TrimSddMgrInnerNode","text":"SDD manager inner vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.TrimSddMgrLeafNode","page":"Logic","title":"LogicCircuits.TrimSddMgrLeafNode","text":"SDD manager leaf vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Unique⋁Cache","page":"Logic","title":"LogicCircuits.Unique⋁Cache","text":"Unique nodes cache for decision nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Vtree","page":"Logic","title":"LogicCircuits.Vtree","text":"Root of the vtree node hiearchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.XYPartition","page":"Logic","title":"LogicCircuits.XYPartition","text":"Represent an XY-partition that has not yet been compiled into a disjunction\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀Gate","page":"Logic","title":"LogicCircuits.⋀Gate","text":"A trait denoting conjuction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁Gate","page":"Logic","title":"LogicCircuits.⋁Gate","text":"A trait denoting disjunction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#Base.deepcopy","page":"Logic","title":"Base.deepcopy","text":"Create a copy circuit n to a certain depth depth\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#Base.merge-Tuple{Node,Node,Node}","page":"Logic","title":"Base.merge","text":"Merge two circuits\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.split-Tuple{Node,Tuple{Node,Node},UInt32}","page":"Logic","title":"Base.split","text":"Return the circuit after spliting on edge edge and variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.children-Tuple{PlainLogicInnerNode}","page":"Logic","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{LogicCircuit,Function,Function,Function,Function,Type{T}}} where T","page":"Logic","title":"LogicCircuits.Utils.foldup","text":"Compute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{LogicCircuit,Function,Function,Function,Function,Type{T}}} where T","page":"Logic","title":"LogicCircuits.Utils.foldup_aggregate","text":"Compute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.lca-Tuple{Vtree,Vtree}","page":"Logic","title":"LogicCircuits.Utils.lca","text":"Compute the lowest common ancestor of two vtree nodes Warning: this method uses an imcomplete varsubset check for descends_from and is only correct when v and w are part of the same larger vtree.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.and_nodes-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.and_nodes","text":"Get the list of And nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.balanced_vtree-Union{Tuple{VN}, Tuple{Type{VN},Int64}} where VN<:Vtree","page":"Logic","title":"LogicCircuits.balanced_vtree","text":"Construct a balanced vtree with the given number of variables\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.balanced_vtree-Union{Tuple{VN}, Tuple{Type{VN},UInt32,UInt32}} where VN<:Vtree","page":"Logic","title":"LogicCircuits.balanced_vtree","text":"Construct a balanced vtree with variables ranging from first to last (inclusive)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.bottom_up_vtree-Union{Tuple{VN}, Tuple{Type{VN},Array{UInt32,1},Function}} where VN<:Vtree","page":"Logic","title":"LogicCircuits.bottom_up_vtree","text":"Construct Vtree bottom up, using method specified by combine_method!.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_constants-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.canonical_constants","text":"Construct a mapping from constants to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_literals-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.canonical_literals","text":"Construct a mapping from literals to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize-Tuple{Array{LogicCircuits.Element,1}}","page":"Logic","title":"LogicCircuits.canonicalize","text":"Get the canonical compilation of the given XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize_compressed-Tuple{Array{LogicCircuits.Element,1}}","page":"Logic","title":"LogicCircuits.canonicalize_compressed","text":"Get the canonical compilation of the given compressed XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.clone-NTuple{4,Node}","page":"Logic","title":"LogicCircuits.clone","text":"Clone the or node and redirect one of its parents to the new copy\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compile","page":"Logic","title":"LogicCircuits.compile","text":"Create new circuit nodes in the given context.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.compress-Tuple{Array{LogicCircuits.Element,1}}","page":"Logic","title":"LogicCircuits.compress","text":"Compress a given XY Partition (merge elements with identical subs)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.condition-Tuple{Node,Int32}","page":"Logic","title":"LogicCircuits.condition","text":"Return the circuit conditioned on given literal constrains callback is called after modifying conjunction node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin","page":"Logic","title":"LogicCircuits.conjoin","text":"Conjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin-Tuple{SddFalseNode,SddTrueNode}","page":"Logic","title":"LogicCircuits.conjoin","text":"Conjoin two SDDs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_cartesian-Tuple{Sdd⋁Node,Sdd⋁Node}","page":"Logic","title":"LogicCircuits.conjoin_cartesian","text":"Conjoin two SDDs when they respect the same vtree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_descendent-Tuple{Sdd,Sdd}","page":"Logic","title":"LogicCircuits.conjoin_descendent","text":"Conjoin two SDDs when one descends from the other\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_indep-Tuple{Sdd,Sdd}","page":"Logic","title":"LogicCircuits.conjoin_indep","text":"Conjoin two SDDs in separate parts of the vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.constant","page":"Logic","title":"LogicCircuits.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.constant-Tuple{PlainTrueNode}","page":"Logic","title":"LogicCircuits.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.depth-Tuple{Vtree,UInt32}","page":"Logic","title":"LogicCircuits.depth","text":"Compute the path length from vtree node n to leaf node which contains var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.disjoin","page":"Logic","title":"LogicCircuits.disjoin","text":"Disjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.find_leaf-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.find_leaf","text":"Find the leaf in the vtree that represents the given variable\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.forget-Tuple{Node,Function}","page":"Logic","title":"LogicCircuits.forget","text":"Forget variables from the circuit. Warning: this may or may not destroy the determinism property.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.fully_factorized_circuit","page":"Logic","title":"LogicCircuits.fully_factorized_circuit","text":"Generate a fully factorized circuit over the given range of variables\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.goes_left-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.goes_left","text":"Is the variable v contained in the left branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.goes_right-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.goes_right","text":"Is the variable v contained in the right branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.iscanonical-Tuple{LogicCircuit,Int64}","page":"Logic","title":"LogicCircuits.iscanonical","text":"Does the given circuit have canonical Or gates, as determined by a probabilistic equivalence check?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isconstantgate-Tuple{Any}","page":"Logic","title":"LogicCircuits.isconstantgate","text":"Is the node a constant gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdecomposable-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.isdecomposable","text":"Is the circuit decomposable?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isfalse-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.isfalse","text":"Is the circuit syntactically equal to false?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isinnergate-Tuple{Any}","page":"Logic","title":"LogicCircuits.isinnergate","text":"Is the node an inner gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isliteralgate-Tuple{Any}","page":"Logic","title":"LogicCircuits.isliteralgate","text":"Is the node a literal gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.ispositive-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.ispositive","text":"Get the sign of the literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.issmooth-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.issmooth","text":"Is the circuit smooth?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.istrue-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.istrue","text":"Is the circuit syntactically equal to true?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋀gate-Tuple{Any}","page":"Logic","title":"LogicCircuits.is⋀gate","text":"Is the node an And gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋁gate-Tuple{Any}","page":"Logic","title":"LogicCircuits.is⋁gate","text":"Is the node an Or gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.lca_vtree-Tuple","page":"Logic","title":"LogicCircuits.lca_vtree","text":"Find the LCA vtree of all given nodes, excluding constant nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literal-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.literal","text":"Get the logical literal in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.matching_vtree-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.matching_vtree","text":"Find a vtree node that can be respected by the given prime and sub\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.mgr-Tuple{Sdd}","page":"Logic","title":"LogicCircuits.mgr","text":"Get the manager of a Sdd node, which is its SddMgr vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.model_count","page":"Logic","title":"LogicCircuits.model_count","text":"Get the model count of the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.negate-Tuple{SddFalseNode}","page":"Logic","title":"LogicCircuits.negate","text":"Negate an SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.or_nodes-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.or_nodes","text":"Get the list of or nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prime-Tuple{Sdd⋀Node}","page":"Logic","title":"LogicCircuits.prime","text":"Get the prime, that is, the first conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prob_equiv_signature-Tuple{LogicCircuit,Int64}","page":"Logic","title":"LogicCircuits.prob_equiv_signature","text":"Get a signature for each node using probabilistic equivalence checking. Note that this implentation may not have any formal guarantees as such.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.propagate_constants-Tuple{Node}","page":"Logic","title":"LogicCircuits.propagate_constants","text":"Remove all constant leafs from the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.replace_node-Tuple{Node,Node,Node}","page":"Logic","title":"LogicCircuits.replace_node","text":"Replace node old with node new in circuit root\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sat_prob","page":"Logic","title":"LogicCircuits.sat_prob","text":"Get the probability that a random world satisties the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_num_nodes-Tuple{Sdd}","page":"Logic","title":"LogicCircuits.sdd_num_nodes","text":"Count the number of decision nodes in the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_size-Tuple{Sdd}","page":"Logic","title":"LogicCircuits.sdd_size","text":"Count the number of elements in the decision nodes of the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth-Tuple{Node}","page":"Logic","title":"LogicCircuits.smooth","text":"Create an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth_node-Tuple{Node,Any,Any}","page":"Logic","title":"LogicCircuits.smooth_node","text":"Return a smooth version of the node where  the missing_scope variables are added to the scope, using literals from lit_nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sub-Tuple{Sdd⋀Node}","page":"Logic","title":"LogicCircuits.sub","text":"Get the sub, that is, the second and last conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.top_down_root-Union{Tuple{VN}, Tuple{Type{VN},Array{UInt32,1},Function}} where VN<:Vtree","page":"Logic","title":"LogicCircuits.top_down_root","text":"Construct Vtree top town, using method specified by split_method.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.tree_formula_string-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.tree_formula_string","text":"Get the formula of a given circuit as a string, expanding the formula into a tree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.unique⋁","page":"Logic","title":"LogicCircuits.unique⋁","text":"Construct a unique decision gate for the given vtree\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable","page":"Logic","title":"LogicCircuits.variable","text":"Get the variable in a vtree leaf\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.variable","text":"Get the logical variable in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.variables_by_node-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.variables_by_node","text":"Get the variable scope of each node in the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_left-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.varsubset_left","text":"Are the variables in n contained in the left branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_right-Tuple{Any,Any}","page":"Logic","title":"LogicCircuits.varsubset_right","text":"Are the variables in n contained in the right branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.vtree-Tuple{Any}","page":"Logic","title":"LogicCircuits.vtree","text":"Get the vtree corresponding to the argument\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀_nodes-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.⋀_nodes","text":"Get the list of conjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁_nodes-Tuple{LogicCircuit}","page":"Logic","title":"LogicCircuits.⋁_nodes","text":"Get the list of disjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/public/#api-public","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/public/","page":"Public API","title":"Public API","text":"Documentation for LogicCircuits.jl's public interface.","category":"page"},{"location":"api/public/","page":"Public API","title":"Public API","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"api/public/#Contents","page":"Public API","title":"Contents","text":"","category":"section"},{"location":"api/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"api/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Public-Interface","page":"Public API","title":"Public Interface","text":"","category":"section"},{"location":"api/public/","page":"Public API","title":"Public API","text":"load_logic_circuit\nload_smooth_logic_circuit","category":"page"},{"location":"api/public/#LogicCircuits.LoadSave.load_logic_circuit","page":"Public API","title":"LogicCircuits.LoadSave.load_logic_circuit","text":"Load a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.load_smooth_logic_circuit","page":"Public API","title":"LogicCircuits.LoadSave.load_smooth_logic_circuit","text":"Load a smooth logical circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/","page":"Public API","title":"Public API","text":"note: Note\nThis list is not complete yet, will be adding more here as the public API gets finalized.","category":"page"}]
}
