var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.5 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-LogicCircuits","page":"Installation","title":"Installing LogicCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"LogicCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package with the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"))'","category":"page"},{"location":"installation/#From-Julia-Pkg-REPL","page":"Installation","title":"From Julia Pkg REPL","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits#master","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"LogicCircuits\")'","category":"page"},{"location":"manual/compilation/#man-compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"manual/compilation/","page":"Compilation","title":"Compilation","text":"note: Note\nMore examples coming soon, for now please refer to the Juice Examples Repository","category":"page"},{"location":"api/internals/loadsave/#api-internal-loadsave","page":"LoadSave","title":"LoadSave","text":"","category":"section"},{"location":"api/internals/loadsave/","page":"LoadSave","title":"LoadSave","text":"Modules = [LogicCircuits.LoadSave]","category":"page"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.BiasLine","page":"LoadSave","title":"LogicCircuits.LoadSave.BiasLine","text":"A line representing a bias node in the circuit (an OR with one child)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitCommentLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitCommentLine","text":"A string comment line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitFormatLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitFormatLine","text":"A parsed circuit file format line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitFormatLines","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitFormatLines","text":"A file consisting for circuit formal lines\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.CircuitHeaderLine","page":"LoadSave","title":"LogicCircuits.LoadSave.CircuitHeaderLine","text":"A header line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.ConstantLine","page":"LoadSave","title":"LogicCircuits.LoadSave.ConstantLine","text":"A line representing either the true or false logical constants\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.DecisionLine","page":"LoadSave","title":"LogicCircuits.LoadSave.DecisionLine","text":"A line representing a decision node in the circuit (an OR of AND elements)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.Element","page":"LoadSave","title":"LogicCircuits.LoadSave.Element","text":"Paired boxes, or elements, are conjunctions  in a larger decision node line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.ID","page":"LoadSave","title":"LogicCircuits.LoadSave.ID","text":"Circuit and vtree node ids used for IO\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.InnerCircuitLine","page":"LoadSave","title":"LogicCircuits.LoadSave.InnerCircuitLine","text":"A circuit format line with child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.LeafCircuitLine","page":"LoadSave","title":"LogicCircuits.LoadSave.LeafCircuitLine","text":"A circuit format line without child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.LiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.LiteralLine","text":"A line that represents a logical literal\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.UnweightedLiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.UnweightedLiteralLine","text":"A line representing a single literal without parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.VtreeAbstractFile","page":"LoadSave","title":"LogicCircuits.LoadSave.VtreeAbstractFile","text":"Used to specify file type .vtree or .dot\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.VtreeFormatLine","page":"LoadSave","title":"LogicCircuits.LoadSave.VtreeFormatLine","text":"A line in the vtree file format\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.WeightedLiteralLine","page":"LoadSave","title":"LogicCircuits.LoadSave.WeightedLiteralLine","text":"A line representing a weighted single literal (for example a logistic circuit literal).\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.WeightedNamedConstantLine","page":"LoadSave","title":"LogicCircuits.LoadSave.WeightedNamedConstantLine","text":"A weighted constant line for a known variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_logical-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_logical","text":"Compile lines into a unstructured logic circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_logical_m-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_logical_m","text":"Compile lines into a unstructured logic circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_logical-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_logical","text":"Compile lines into a smooth unstructured logic circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_logical_m-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_logical_m","text":"Compile lines into a smooth unstructured logic circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine,AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.VtreeFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical","text":"Compile circuit and vtree lines into a structured logic circuit with its vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical_m-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine,AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.VtreeFormatLine}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical_m","text":"Compile circuit and vtree lines into a structured logic circuit with its vtree,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.compile_smooth_struct_logical_m-Tuple{AbstractArray{var\"#s74\",1} where var\"#s74\"<:LogicCircuits.LoadSave.CircuitFormatLine,Dict{UInt32,PlainVtree}}","page":"LoadSave","title":"LogicCircuits.LoadSave.compile_smooth_struct_logical_m","text":"Compile circuit lines and vtree node mapping into a structured logic circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.decompile-Tuple{Union{PlainStructLiteralNode, SddLiteralNode},Any,Any}","page":"LoadSave","title":"LogicCircuits.LoadSave.decompile","text":"Decompile for sdd circuit, used during saving of circuits to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.get_level_nodes-Tuple{LogicCircuit}","page":"LoadSave","title":"LogicCircuits.LoadSave.get_level_nodes","text":"Effectively returns the inverse of get_nodes_level, returning a dictionary where keys are the nodes and values are their levels, and the highest level in the circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.get_nodes_level-Tuple{Node}","page":"LoadSave","title":"LogicCircuits.LoadSave.get_nodes_level","text":"Rank nodes in the same layer left to right\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_cnf-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_cnf","text":"load_cnf(file::String; dual=false)::PlainLogicCircuit\n\nLoad a CNF/DNF as a logic circuit from file. Suppported file formats:\n\n\".cnf\" for CNF files  (dual=False)\n\".dnf\" for DNF files  (dual=True)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_dnf-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_dnf","text":"load_dnf(file::String)::PlainLogicCircuit\n\nLoad a DNF as a logical circuit from file.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_logic_circuit-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_logic_circuit","text":"load_logic_circuit(file::String)::PlainLogicCircuit\n\nLoad a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_smooth_logic_circuit-Tuple{String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_smooth_logic_circuit","text":"load_smooth_logic_circuit(file::String)::PlainLogicCircuit\n\nLoad a smooth logic circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_struct_smooth_logic_circuit-Tuple{String,String}","page":"LoadSave","title":"LogicCircuits.LoadSave.load_struct_smooth_logic_circuit","text":"load_struct_smooth_logic_circuit(circuit_file::String, vtree_file::String)::Tuple{StructLogicCircuit,PlainVtree}\n\nLoad a smooth structured logic circuit and its vtree from file. Supported circuit file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\nSupported vtree file formats:\n\n\".vtree\" for Vtree files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.load_vtree-Union{Tuple{String}, Tuple{V}, Tuple{String,Type{V}}} where V<:Vtree","page":"LoadSave","title":"LogicCircuits.LoadSave.load_vtree","text":"load_vtree(file::String, ::Type{V}=PlainVtree)::V where V<:Vtree\n\nLoad a vtree file from file. Currently only supports \".vtree\" format.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_dot-Tuple{LogicCircuit,String}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_dot","text":"save_as_dot(circuit::LogicCircuit, file::String)\n\nSave logic circuit in 'dot' file format.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_dot2tex","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_dot2tex","text":"save_as_dot2tex(circuit::LogicCircuit, file::String; **other_args)\n\nSave logic circuit as a LaTeX TikZ .tex file using the dot2tex engine.\n\nArgument V is a label map for each vertex; E is a label map for each edge; ⋀_style, ⋁_style, lit_style, ⊤_style, and ⊥_style are styles for each node type; edge_turn is how far down should edges \"bend\"; node_xsep and node_ysep are x and y-axis separation sizes for terminal nodes.\n\nNote: save_as_tex does not work well on large circuits, and the resulting LaTeX file should serve as a first sketch in (serious) need for adjustments.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_sdd-Tuple{String,Any,Any}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_sdd","text":"save_as_sdd(name::String, circuit, vtree)\n\nSave a SDD circuit to file. File name should end with '.sdd'.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_as_tex-Tuple{LogicCircuit,String}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_as_tex","text":"save_as_tex(circuit::LogicCircuit, file::String; **other_args)\n\nSave logic circuit as a LaTeX TikZ .tex file. Argument V is a label map for each vertex, E is a label map for each edge, ⋀_style is the TikZ conjunction node style to use, ⋁_style is the TikZ disjunction node style to use, node_ysep is the y-axis separation distance for nodes, node_xsep for the x-axis, edge_turn is how far down should edges \"bend\", verbose if set to true prints comments to the LaTeX file for better readability.\n\nNote: save_as_tex does not work well on large circuits, and the resulting LaTeX file should serve as a first sketch in (serious) need for adjustments.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_circuit-Tuple{String,Any,Any}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_circuit","text":"save_circuit(name::String, circuit, vtree)\n\nSave a circuit to file. Currently defaults to and only supports saving '.sdd' format.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.save_vtree-Tuple{PlainVtree,AbstractString}","page":"LoadSave","title":"LogicCircuits.LoadSave.save_vtree","text":"save_vtree(vtree::PlainVtree, file::AbstractString)\n\nSaves a vtree in the given file path based on file format. Supported formats:\n\n\".vtree\" for Vtree files\n\".dot\" for dot files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/loadsave/#LogicCircuits.LoadSave.sdd_header-Tuple{}","page":"LoadSave","title":"LogicCircuits.LoadSave.sdd_header","text":"Returns header for SDD file format\n\n\n\n\n\n","category":"method"},{"location":"api/public/#api-public","page":"Public APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"This page lists documentation for the most commonly used public APIs of LogicCircuits.jl. Visit the internals section for a auto generated documentation for more public API and internal APIs.","category":"page"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Loading-Circuits","page":"Public APIs","title":"Loading Circuits","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"load_cnf\nload_dnf\nload_logic_circuit\nload_smooth_logic_circuit\nload_struct_smooth_logic_circuit","category":"page"},{"location":"api/public/#LogicCircuits.LoadSave.load_cnf","page":"Public APIs","title":"LogicCircuits.LoadSave.load_cnf","text":"load_cnf(file::String; dual=false)::PlainLogicCircuit\n\nLoad a CNF/DNF as a logic circuit from file. Suppported file formats:\n\n\".cnf\" for CNF files  (dual=False)\n\".dnf\" for DNF files  (dual=True)\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.load_dnf","page":"Public APIs","title":"LogicCircuits.LoadSave.load_dnf","text":"load_dnf(file::String)::PlainLogicCircuit\n\nLoad a DNF as a logical circuit from file.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.load_logic_circuit","page":"Public APIs","title":"LogicCircuits.LoadSave.load_logic_circuit","text":"load_logic_circuit(file::String)::PlainLogicCircuit\n\nLoad a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.load_smooth_logic_circuit","page":"Public APIs","title":"LogicCircuits.LoadSave.load_smooth_logic_circuit","text":"load_smooth_logic_circuit(file::String)::PlainLogicCircuit\n\nLoad a smooth logic circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.load_struct_smooth_logic_circuit","page":"Public APIs","title":"LogicCircuits.LoadSave.load_struct_smooth_logic_circuit","text":"load_struct_smooth_logic_circuit(circuit_file::String, vtree_file::String)::Tuple{StructLogicCircuit,PlainVtree}\n\nLoad a smooth structured logic circuit and its vtree from file. Supported circuit file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\nSupported vtree file formats:\n\n\".vtree\" for Vtree files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Saving-Circuits","page":"Public APIs","title":"Saving Circuits","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"save_circuit\nsave_vtree\nsave_as_sdd\nsave_as_dot\nsave_as_tex\nsave_as_dot2tex","category":"page"},{"location":"api/public/#LogicCircuits.LoadSave.save_circuit","page":"Public APIs","title":"LogicCircuits.LoadSave.save_circuit","text":"save_circuit(name::String, circuit, vtree)\n\nSave a circuit to file. Currently defaults to and only supports saving '.sdd' format.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_vtree","page":"Public APIs","title":"LogicCircuits.LoadSave.save_vtree","text":"save_vtree(vtree::PlainVtree, file::AbstractString)\n\nSaves a vtree in the given file path based on file format. Supported formats:\n\n\".vtree\" for Vtree files\n\".dot\" for dot files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_as_sdd","page":"Public APIs","title":"LogicCircuits.LoadSave.save_as_sdd","text":"save_as_sdd(name::String, circuit, vtree)\n\nSave a SDD circuit to file. File name should end with '.sdd'.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_as_dot","page":"Public APIs","title":"LogicCircuits.LoadSave.save_as_dot","text":"save_as_dot(circuit::LogicCircuit, file::String)\n\nSave logic circuit in 'dot' file format.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_as_tex","page":"Public APIs","title":"LogicCircuits.LoadSave.save_as_tex","text":"save_as_tex(circuit::LogicCircuit, file::String; **other_args)\n\nSave logic circuit as a LaTeX TikZ .tex file. Argument V is a label map for each vertex, E is a label map for each edge, ⋀_style is the TikZ conjunction node style to use, ⋁_style is the TikZ disjunction node style to use, node_ysep is the y-axis separation distance for nodes, node_xsep for the x-axis, edge_turn is how far down should edges \"bend\", verbose if set to true prints comments to the LaTeX file for better readability.\n\nNote: save_as_tex does not work well on large circuits, and the resulting LaTeX file should serve as a first sketch in (serious) need for adjustments.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.LoadSave.save_as_dot2tex","page":"Public APIs","title":"LogicCircuits.LoadSave.save_as_dot2tex","text":"save_as_dot2tex(circuit::LogicCircuit, file::String; **other_args)\n\nSave logic circuit as a LaTeX TikZ .tex file using the dot2tex engine.\n\nArgument V is a label map for each vertex; E is a label map for each edge; ⋀_style, ⋁_style, lit_style, ⊤_style, and ⊥_style are styles for each node type; edge_turn is how far down should edges \"bend\"; node_xsep and node_ysep are x and y-axis separation sizes for terminal nodes.\n\nNote: save_as_tex does not work well on large circuits, and the resulting LaTeX file should serve as a first sketch in (serious) need for adjustments.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Properties","page":"Public APIs","title":"Circuit Properties","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"issmooth\nisdecomposable\nisdeterministic\niscanonical","category":"page"},{"location":"api/public/#LogicCircuits.issmooth","page":"Public APIs","title":"LogicCircuits.issmooth","text":"issmooth(root::LogicCircuit)::Bool\n\nIs the circuit smooth?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.isdecomposable","page":"Public APIs","title":"LogicCircuits.isdecomposable","text":"isdecomposable(root::LogicCircuit)::Bool\n\nIs the circuit decomposable?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.isdeterministic","page":"Public APIs","title":"LogicCircuits.isdeterministic","text":"isdeterministic(root::LogicCircuit)::Bool\n\nIs the circuit determinstic? Note: this function is generally intractable for large circuits.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.iscanonical","page":"Public APIs","title":"LogicCircuits.iscanonical","text":"iscanonical(circuit::LogicCircuit, k::Int; verbose = false)\n\nDoes the given circuit have canonical Or gates, as determined by a probabilistic equivalence check?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Queries","page":"Public APIs","title":"Circuit Queries","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"sat_prob\nmodel_count","category":"page"},{"location":"api/public/#LogicCircuits.sat_prob","page":"Public APIs","title":"LogicCircuits.sat_prob","text":"sat_prob(root::LogicCircuit; varprob::Function)::Rational{BigInt}\n\nGet the probability that a random world satisties the circuit.  Probability of each variable is given by varprob Function which defauls to 1/2 for every variable.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.model_count","page":"Public APIs","title":"LogicCircuits.model_count","text":"model_count(root::LogicCircuit, num_vars_in_scope::Int = num_variables(root))::BigInt\n\nGet the model count of the circuit.  The num_vars_in_scope is set to number of variables in the circuit, but sometimes need to set different values,  for example, if not every variable is mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Operations","page":"Public APIs","title":"Circuit Operations","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"foldup\nfoldup_aggregate","category":"page"},{"location":"api/public/#LogicCircuits.Utils.foldup","page":"Public APIs","title":"LogicCircuits.Utils.foldup","text":"foldup(node::Dag, \n    f_leaf::Function, \n    f_inner::Function, \n    ::Type{T}; nload = nload, nsave = nsave, reset=true)::T where {T}\n\nCompute a function bottom-up on the graph.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\nfoldup(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T}; nload = nload, nsave = nsave, reset=true)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.Utils.foldup_aggregate","page":"Public APIs","title":"LogicCircuits.Utils.foldup_aggregate","text":"foldup_aggregate(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T};  nload = nload, nsave = nsave, reset=true)::T where T\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Transformations","page":"Public APIs","title":"Circuit Transformations","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"smooth\ncondition\nforget\ndeepcopy","category":"page"},{"location":"api/public/#LogicCircuits.smooth","page":"Public APIs","title":"LogicCircuits.smooth","text":"smooth(root::Node)::Node\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.condition","page":"Public APIs","title":"LogicCircuits.condition","text":"condition(root::Node, lit::Lit; callback::Function)::Node\n\nReturn the circuit conditioned on given literal constrains callback is called after modifying conjunction node\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.forget","page":"Public APIs","title":"LogicCircuits.forget","text":"forget(root::Node, is_forgotten::Function)::Node\n\nForget variables from the circuit. Warning: this may or may not destroy the determinism property.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Base.deepcopy","page":"Public APIs","title":"Base.deepcopy","text":"deepcopy(n::Node, depth::Int64)\n\nRecursively create a copy circuit rooted at n to a certain depth depth\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Compilation","page":"Public APIs","title":"Compilation","text":"","category":"section"},{"location":"api/types/#api-types","page":"Type Trees","title":"Type Trees","text":"","category":"section"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"The following code snippet provides an easy way to print the type tree of logic circuits.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"using InteractiveUtils;\nusing LogicCircuits;\nusing AbstractTrees;\nAbstractTrees.children(x::Type) = subtypes(x);","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"For example, we can see LogicCircuits.LogicCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(LogicCircuit)","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"Alternatively, here's Vtree's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(Vtree)","category":"page"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/#Evaluation","page":"Queries","title":"Evaluation","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta and an assignment to its variable, we would like to know the output of the circuit. For example, if Delta = X land Y, and we assign x, lnot y:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"X land Y = texttrue land textfalse = textfalse","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_psdd_file(\"plants.psdd\"));\ntrain, valid, test = twenty_datasets(\"plants\");\n\nresults = lc(train);\nresults[1:3]","category":"page"},{"location":"manual/queries/#Satisfiability","page":"Queries","title":"Satisfiability","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta, the goal of SAT is to answer whether there is an assignment to its variables such that the output is true. Depending on the structural properties of the logic circuit this problem can be intractable or tractable.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can use sat_prob to compute probability of a random world satisfying the circuit. Note that sat_prob assumes that we have a smooth, deterministic, and decomposable circuit.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nprob = sat_prob(lc);\nFloat64(prob)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"By default, every postive literal x_i has probability 1/2, we can set probability of literal values to any constant probabilities, for example:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"prob = sat_prob(lc; varprob = (i) -> BigInt(1) // BigInt(3));\nFloat64(prob)","category":"page"},{"location":"manual/queries/#Model-Counting","page":"Queries","title":"Model Counting","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta, the goal of model counting is to count how many ways there are to assign values to variables of Delta such that the output of the circuit is true. Note that model_count assumes we have a smooth, deterministic, and decomposable circuit.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = smooth(load_logic_circuit(zoo_sdd_file(\"random.sdd\")));\nmodel_count(lc)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Lets see how forgetting a variable affects the model count. Note that to get the correct model count need to give the number of vairables in the original circuit.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"f2 = forget(lc, (i) -> (i == 2));\nmodel_count(f2, num_variables(lc))","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Lets see how conditioning affects the model count. Observe that model count of Delta should equal to adding model counts of Delta mid x_2 and Delta mid lnot x_2.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"c2 = condition(lc, Lit(2));\nc2not = condition(lc, Lit(-2));\nmodel_count(c2, num_variables(lc)), model_count(c2not, num_variables(lc))","category":"page"},{"location":"manual/queries/#Equivalence-Checking","page":"Queries","title":"Equivalence Checking","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given two logic circuits Delta_1 and Delta_2, the goal is to check whether these two circuits represent the same formula. There are both determnistic and probabilistic algorithms for this task.","category":"page"},{"location":"api/internals/logiccircuits/#api-internal-logic-circuits","page":"LogicCircuits","title":"LogicCircuits","text":"","category":"section"},{"location":"api/internals/logiccircuits/","page":"LogicCircuits","title":"LogicCircuits","text":"Modules = [LogicCircuits]","category":"page"},{"location":"api/internals/logiccircuits/#LogicCircuits.Batch","page":"LogicCircuits","title":"LogicCircuits.Batch","text":"Input types supported by flow algorithms\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.UpDownFlow","page":"LogicCircuits","title":"LogicCircuits.UpDownFlow","text":"Any container for up/down flow\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.UpFlow","page":"LogicCircuits","title":"LogicCircuits.UpFlow","text":"Flows of type F, or their implicit representation as an UpFlow2\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.false_sdd","page":"LogicCircuits","title":"LogicCircuits.false_sdd","text":"Canonical false Sdd node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.structfalse","page":"LogicCircuits","title":"LogicCircuits.structfalse","text":"The unique splain tructured logical false constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.structtrue","page":"LogicCircuits","title":"LogicCircuits.structtrue","text":"The unique plain structured logical true constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.true_sdd","page":"LogicCircuits","title":"LogicCircuits.true_sdd","text":"Canonical true Sdd node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.ApplyArgs","page":"LogicCircuits","title":"LogicCircuits.ApplyArgs","text":"Representation of the arguments of an Apply call\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.ApplyCache","page":"LogicCircuits","title":"LogicCircuits.ApplyCache","text":"Apply cache for the result of conjunctions and disjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.BitCircuit","page":"LogicCircuits","title":"LogicCircuits.BitCircuit","text":"A bit circuit is a sequence of layers of decision nodes,  which have node ids assuming num_features input features in the 0th layer. They are a \"flat\" representation of a circuit, essentially a bit string, that can be processed by lower level code (i.e., GPU kernels) The E elements are represented by a 3xE matrix, where \n\nelements[1,:] are the decision node ids,\nelements[2,:] are the prime node ids, and \nelements[3,:] are the sub node ids.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.BitCircuit-Tuple{LogicCircuit,Int64}","page":"LogicCircuits","title":"LogicCircuits.BitCircuit","text":"construct a new BitCircuit accomodating the given number of features\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.BitFlow2","page":"LogicCircuits","title":"LogicCircuits.BitFlow2","text":"Implicit conjunction of two Boolean flows\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.ConstantGate","page":"LogicCircuits","title":"LogicCircuits.ConstantGate","text":"A trait denoting constant leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Element","page":"LogicCircuits","title":"LogicCircuits.Element","text":"Represents elements that are not yet compiled into conjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.FloatFlow2","page":"LogicCircuits","title":"LogicCircuits.FloatFlow2","text":"Implicit conjunction of two Float flows\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.FloatVector","page":"LogicCircuits","title":"LogicCircuits.FloatVector","text":"A vector of some float type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType","page":"LogicCircuits","title":"LogicCircuits.GateType","text":"A trait hierarchy denoting types of nodes GateType defines an orthogonal type hierarchy of node types, not circuit types, so we can dispatch on node type regardless of circuit type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.GateType","text":"Get the gate type trait of the given LogicCircuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.InnerGate","page":"LogicCircuits","title":"LogicCircuits.InnerGate","text":"A logical gate that is an inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LeafGate","page":"LogicCircuits","title":"LogicCircuits.LeafGate","text":"A logical gate that is a leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LiteralGate","page":"LogicCircuits","title":"LogicCircuits.LiteralGate","text":"A trait denoting literal leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LogicCircuit","page":"LogicCircuits","title":"LogicCircuits.LogicCircuit","text":"Root of the logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.NodeId","page":"LogicCircuits","title":"LogicCircuits.NodeId","text":"The BitCircuit ids associated with a node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainConstantNode","page":"LogicCircuits","title":"LogicCircuits.PlainConstantNode","text":"A plain logical constant leaf node, representing true or false\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainFalseNode","page":"LogicCircuits","title":"LogicCircuits.PlainFalseNode","text":"Plain constant false node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLiteralNode","page":"LogicCircuits","title":"LogicCircuits.PlainLiteralNode","text":"A plain logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.PlainLogicCircuit","text":"Root of the plain logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicInnerNode","page":"LogicCircuits","title":"LogicCircuits.PlainLogicInnerNode","text":"A plain logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicLeafNode","page":"LogicCircuits","title":"LogicCircuits.PlainLogicLeafNode","text":"A plain logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructConstantNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructConstantNode","text":"A plain structured logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructFalseNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructFalseNode","text":"A plain structured logical false constant.  Never construct one, use structfalse to access its unique instance\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLiteralNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLiteralNode","text":"A plain structured logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicCircuit","text":"Root of the plain structure logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicInnerNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicInnerNode","text":"A plain structured logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicLeafNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicLeafNode","text":"A plain structured logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructTrueNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructTrueNode","text":"A plain structured logical true constant. Never construct one, use structtrue to access its unique instance\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋀Node","page":"LogicCircuits","title":"LogicCircuits.PlainStruct⋀Node","text":"A plain structured logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋁Node","page":"LogicCircuits","title":"LogicCircuits.PlainStruct⋁Node","text":"A plain structured logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainTrueNode","page":"LogicCircuits","title":"LogicCircuits.PlainTrueNode","text":"Plain constant true node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainVtree","page":"LogicCircuits","title":"LogicCircuits.PlainVtree","text":"Root of the plain vtree node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋀Node","page":"LogicCircuits","title":"LogicCircuits.Plain⋀Node","text":"A plain logical conjunction node (And node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋁Node","page":"LogicCircuits","title":"LogicCircuits.Plain⋁Node","text":"A plain logical disjunction node (Or node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd","page":"LogicCircuits","title":"LogicCircuits.Sdd","text":"Root of the trimmed Sdd circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddConstantNode","page":"LogicCircuits","title":"LogicCircuits.SddConstantNode","text":"A SDD logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddFalseNode","page":"LogicCircuits","title":"LogicCircuits.SddFalseNode","text":"A SDD logical false constant.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddInnerNode","page":"LogicCircuits","title":"LogicCircuits.SddInnerNode","text":"A SDD logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLeafNode","page":"LogicCircuits","title":"LogicCircuits.SddLeafNode","text":"A SDD logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLiteralNode","page":"LogicCircuits","title":"LogicCircuits.SddLiteralNode","text":"A SDD logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgr","page":"LogicCircuits","title":"LogicCircuits.SddMgr","text":"Root of the SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgrInnerNode","page":"LogicCircuits","title":"LogicCircuits.SddMgrInnerNode","text":"SDD manager inner vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgrLeafNode","page":"LogicCircuits","title":"LogicCircuits.SddMgrLeafNode","text":"SDD manager leaf vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddTrueNode","page":"LogicCircuits","title":"LogicCircuits.SddTrueNode","text":"A SDD logical true constant.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋀Node","page":"LogicCircuits","title":"LogicCircuits.Sdd⋀Node","text":"A SDD logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋁Node","page":"LogicCircuits","title":"LogicCircuits.Sdd⋁Node","text":"A SDD logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.StructLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.StructLogicCircuit","text":"Root of the structure logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Unique⋁Cache","page":"LogicCircuits","title":"LogicCircuits.Unique⋁Cache","text":"Unique nodes cache for decision nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.UpDownFlow1","page":"LogicCircuits","title":"LogicCircuits.UpDownFlow1","text":"Container for both the upward and downward flow of a given type F\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.UpDownFlow2","page":"LogicCircuits","title":"LogicCircuits.UpDownFlow2","text":"Container for the upward implicit flow of type F, for which no downward flow is stored\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.UpFlow2","page":"LogicCircuits","title":"LogicCircuits.UpFlow2","text":"Container for circuit flows represented as an implicit conjunction of a prime and sub bit vector (saves memory allocations in circuits with many binary conjunctions)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Vtree","page":"LogicCircuits","title":"LogicCircuits.Vtree","text":"Root of the vtree node hiearchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.XYPartition","page":"LogicCircuits","title":"LogicCircuits.XYPartition","text":"Represent an XY-partition that has not yet been compiled into a disjunction\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀Gate","page":"LogicCircuits","title":"LogicCircuits.⋀Gate","text":"A trait denoting conjuction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁Gate","page":"LogicCircuits","title":"LogicCircuits.⋁Gate","text":"A trait denoting disjunction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#Base.deepcopy","page":"LogicCircuits","title":"Base.deepcopy","text":"deepcopy(n::Node, depth::Int64)\n\nRecursively create a copy circuit rooted at n to a certain depth depth\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#Base.merge-Tuple{Node,Node,Node}","page":"LogicCircuits","title":"Base.merge","text":"merge(root::Node, or1::Node, or2::Node)\n\nMerge two circuits.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.split-Tuple{Node,Tuple{Node,Node},UInt32}","page":"LogicCircuits","title":"Base.split","text":"split(root::Node, (or, and)::Tuple{Node, Node}, var::Var; depth=0, sanity_check=true)\n\nReturn the circuit after spliting on edge edge and variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.children-Tuple{PlainLogicInnerNode}","page":"LogicCircuits","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.depth-Tuple{Vtree,UInt32}","page":"LogicCircuits","title":"LogicCircuits.Utils.depth","text":"Compute the path length from vtree node n to leaf node for variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.find_inode-Tuple{Any,Any}","page":"LogicCircuits","title":"LogicCircuits.Utils.find_inode","text":"Find an inner vtree node that has left in its left subtree and right in its right subtree. Supports nothing as a catch-all for any node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.find_leaf-Tuple{UInt32,Vtree}","page":"LogicCircuits","title":"LogicCircuits.Utils.find_leaf","text":"Find the leaf in the vtree that represents the given variable\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{LogicCircuit,Function,Function,Function,Function,Type{T}}} where T","page":"LogicCircuits","title":"LogicCircuits.Utils.foldup","text":"foldup(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T}; nload = nload, nsave = nsave, reset=true)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{LogicCircuit,Function,Function,Function,Function,Type{T}}} where T","page":"LogicCircuits","title":"LogicCircuits.Utils.foldup_aggregate","text":"foldup_aggregate(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T};  nload = nload, nsave = nsave, reset=true)::T where T\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.lca-Tuple{Union{Nothing, Vtree},Union{Nothing, Vtree}}","page":"LogicCircuits","title":"LogicCircuits.Utils.lca","text":"Compute the lowest common ancestor of two vtree nodes Warning: this method uses an incomplete varsubset check for descends_from and is only correct when v and w are part of the same larger vtree.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.num_nodes-Tuple{BitCircuit}","page":"LogicCircuits","title":"LogicCircuits.Utils.num_nodes","text":"How many nodes are indexed by a given bit circuit?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.variables-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.Utils.variables","text":"variables(root::LogicCircuit)::BitSet\n\nGet a bitset of variables mentioned in the circuit root.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.acc_downflow_and-Tuple{BitArray{1},BitArray{1},Any}","page":"LogicCircuits","title":"LogicCircuits.acc_downflow_and","text":"Accumulate the downflow from an And node to its children\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.acc_downflow_or-Tuple{BitArray{1},BitArray{1},BitArray{1},BitArray{1},Any}","page":"LogicCircuits","title":"LogicCircuits.acc_downflow_or","text":"Accumulate the downflow from an Or node to its children\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.and_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.and_nodes","text":"Get the list of And nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.balance_threads-Tuple{Any,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.balance_threads","text":"assign threads to examples and decision nodes so that everything is a power of 2\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_constants-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.canonical_constants","text":"Construct a mapping from constants to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_literals-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.canonical_literals","text":"Construct a mapping from literals to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize-Tuple{Array{LogicCircuits.Element,1},LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.canonicalize","text":"Get the canonical compilation of the given XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize_compressed-Tuple{Array{LogicCircuits.Element,1},LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.canonicalize_compressed","text":"Get the canonical compilation of the given compressed XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.clone-NTuple{4,Node}","page":"LogicCircuits","title":"LogicCircuits.clone","text":"Clone the or node and redirect one of its parents to the new copy\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compile","page":"LogicCircuits","title":"LogicCircuits.compile","text":"Create new circuit nodes in the given context.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.compile-Tuple{LogicCircuits.SddMgrLeafNode,Int32}","page":"LogicCircuits","title":"LogicCircuits.compile","text":"Compile a given variable, literal, or constant\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.complement!-Tuple{BitArray{1},AbstractArray{Bool,1}}","page":"LogicCircuits","title":"LogicCircuits.complement!","text":"Complement a flow (corresponding to logical negation) and assign to sink\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.complement-Tuple{AbstractArray{Bool,1}}","page":"LogicCircuits","title":"LogicCircuits.complement","text":"Complement a flow (corresponding to logical negation)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compress-Tuple{Array{LogicCircuits.Element,1}}","page":"LogicCircuits","title":"LogicCircuits.compress","text":"Compress a given XY Partition (merge elements with identical subs)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compute_flows-Tuple{LogicCircuit,Union{DataFrames.DataFrame, var\"#s47\"} where var\"#s47\"<:(AbstractArray{T,2} where T)}","page":"LogicCircuits","title":"LogicCircuits.compute_flows","text":"Compute the logical or probabilistic flow of data through this circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compute_values_flows","page":"LogicCircuits","title":"LogicCircuits.compute_values_flows","text":"Compute the value and flow of each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.condition-Tuple{Node,Int32}","page":"LogicCircuits","title":"LogicCircuits.condition","text":"condition(root::Node, lit::Lit; callback::Function)::Node\n\nReturn the circuit conditioned on given literal constrains callback is called after modifying conjunction node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin","page":"LogicCircuits","title":"LogicCircuits.conjoin","text":"Conjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin-Tuple{SddFalseNode,SddTrueNode}","page":"LogicCircuits","title":"LogicCircuits.conjoin","text":"Conjoin two SDDs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_cartesian-Tuple{Sdd⋁Node,Sdd⋁Node}","page":"LogicCircuits","title":"LogicCircuits.conjoin_cartesian","text":"Conjoin two SDDs when they respect the same vtree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_descendent-Tuple{Sdd,Sdd}","page":"LogicCircuits","title":"LogicCircuits.conjoin_descendent","text":"Conjoin two SDDs when one descends from the other\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_indep-Tuple{Sdd,Sdd}","page":"LogicCircuits","title":"LogicCircuits.conjoin_indep","text":"Conjoin two SDDs in separate parts of the vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.constant","page":"LogicCircuits","title":"LogicCircuits.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.constant-Tuple{PlainTrueNode}","page":"LogicCircuits","title":"LogicCircuits.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.construct_new_sdd_literal-Tuple{LogicCircuits.SddMgrLeafNode,Int32}","page":"LogicCircuits","title":"LogicCircuits.construct_new_sdd_literal","text":"Helper function to construct new SDD literal objects in SddMgrLeafNode constructor\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.disjoin","page":"LogicCircuits","title":"LogicCircuits.disjoin","text":"Disjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.evaluate-Tuple{LogicCircuit,Vararg{Real,N} where N}","page":"LogicCircuits","title":"LogicCircuits.evaluate","text":"Evaluate the circuit bottom-up for a given input\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.evaluate_layers-Tuple{BitCircuit,Array{T,2} where T}","page":"LogicCircuits","title":"LogicCircuits.evaluate_layers","text":"Evaluate the layers of a bit circuit on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.evaluate_layers-Tuple{BitCircuit,CUDA.CuArray{T,2} where T}","page":"LogicCircuits","title":"LogicCircuits.evaluate_layers","text":"Evaluate the layers of a bit circuit on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.evaluate_layers_cuda-NTuple{4,Any}","page":"LogicCircuits","title":"LogicCircuits.evaluate_layers_cuda","text":"CUDA kernel for circuit evaluation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.flow_type-Tuple{AbstractArray{var\"#s26\",2} where var\"#s26\"<:Bool}","page":"LogicCircuits","title":"LogicCircuits.flow_type","text":"For a given input, what is the right type of the flow data?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.forget-Tuple{Node,Function}","page":"LogicCircuits","title":"LogicCircuits.forget","text":"forget(root::Node, is_forgotten::Function)::Node\n\nForget variables from the circuit. Warning: this may or may not destroy the determinism property.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.fully_factorized_circuit","page":"LogicCircuits","title":"LogicCircuits.fully_factorized_circuit","text":"Generate a fully factorized circuit over the given range of variables\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.init_values-Tuple{AbstractArray{var\"#s73\",N} where N where var\"#s73\"<:AbstractFloat,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.init_values","text":"Initialize values from the data (floating point)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.init_values-Tuple{DataFrames.DataFrame,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.init_values","text":"Initialize values from the data (data frames)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.init_values-Union{Tuple{B}, Tuple{AbstractArray{B,N} where N,Any,Any}} where B<:Unsigned","page":"LogicCircuits","title":"LogicCircuits.init_values","text":"Initialize values from the data (bit vectors)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.iscanonical-Tuple{LogicCircuit,Int64}","page":"LogicCircuits","title":"LogicCircuits.iscanonical","text":"iscanonical(circuit::LogicCircuit, k::Int; verbose = false)\n\nDoes the given circuit have canonical Or gates, as determined by a probabilistic equivalence check?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isconstantgate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isconstantgate","text":"Is the node a constant gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdecomposable-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.isdecomposable","text":"isdecomposable(root::LogicCircuit)::Bool\n\nIs the circuit decomposable?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdeterministic-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.isdeterministic","text":"isdeterministic(root::LogicCircuit)::Bool\n\nIs the circuit determinstic? Note: this function is generally intractable for large circuits.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isfactorized-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isfactorized","text":"Is the flow factorized as a UpFlow2?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isfalse-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.isfalse","text":"Is the circuit syntactically equal to false?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isinnergate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isinnergate","text":"Is the node an inner gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isliteralgate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isliteralgate","text":"Is the node a literal gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.ispositive-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.ispositive","text":"Get the sign of the literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.issmooth-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.issmooth","text":"issmooth(root::LogicCircuit)::Bool\n\nIs the circuit smooth?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.istrue-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.istrue","text":"Is the circuit syntactically equal to true?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋀gate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.is⋀gate","text":"Is the node an And gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋁gate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.is⋁gate","text":"Is the node an Or gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literal-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.literal","text":"Get the logical literal in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literal_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.literal_nodes","text":"Get the list of literal nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.materialize-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.materialize","text":"Turn a implicit UpFlow2{F} into its concrete flow F\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.mgr-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.mgr","text":"Get the manager of a Sdd node, which is its SddMgr vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.model_count","page":"LogicCircuits","title":"LogicCircuits.model_count","text":"model_count(root::LogicCircuit, num_vars_in_scope::Int = num_variables(root))::BigInt\n\nGet the model count of the circuit.  The num_vars_in_scope is set to number of variables in the circuit, but sometimes need to set different values,  for example, if not every variable is mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.negate-Tuple{SddFalseNode}","page":"LogicCircuits","title":"LogicCircuits.negate","text":"Negate an SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.num_elements-Tuple{BitCircuit}","page":"LogicCircuits","title":"LogicCircuits.num_elements","text":"Number of elements (conjunctions) in layer or bit circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.or_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.or_nodes","text":"Get the list of or nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.pass_down_flows","page":"LogicCircuits","title":"LogicCircuits.pass_down_flows","text":"When values of nodes have already been computed, do a downward pass computing the flows at each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.pass_down_flows_layers-Tuple{BitCircuit,Array{T,2} where T,Array{T,2} where T,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.pass_down_flows_layers","text":"Evaluate the layers of a bit circuit on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.pass_down_flows_layers-Tuple{BitCircuit,CUDA.CuArray{T,2} where T,CUDA.CuArray{T,2} where T,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.pass_down_flows_layers","text":"Pass flows down the layers of a bit circuit on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.pass_down_flows_layers_cuda-NTuple{7,Any}","page":"LogicCircuits","title":"LogicCircuits.pass_down_flows_layers_cuda","text":"CUDA kernel for passing flows down circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prime-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.prime","text":"Get the prime, that is, the first conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prob_equiv_signature-Tuple{LogicCircuit,Int64}","page":"LogicCircuits","title":"LogicCircuits.prob_equiv_signature","text":"prob_equiv_signature(circuit::LogicCircuit, k::Int)::Dict{Union{Var,Node},Signature}\n\nGet a signature for each node using probabilistic equivalence checking. Note that this implentation may not have any formal guarantees as such.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.propagate_constants-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.propagate_constants","text":"propagate_constants(root::Node)\n\nRemove all constant leafs from the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.random_split-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.random_split","text":"Randomly picking egde and variable from candidates\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.replace_node-Tuple{Node,Node,Node}","page":"LogicCircuits","title":"LogicCircuits.replace_node","text":"Replace node old with node new in circuit root\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.respects_vtree-Tuple{LogicCircuit,Vtree}","page":"LogicCircuits","title":"LogicCircuits.respects_vtree","text":"Does the circuit respect the given vtree? This function allows for constants in conjunctions, but only when a vtree node can be found where the left and right conjunct can be assigned to the left and right vtree.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.reuseable_flow-Union{Tuple{F}, Tuple{Any,Type{F},Any}} where F","page":"LogicCircuits","title":"LogicCircuits.reuseable_flow","text":"Return a reusable flow vector if one is already allocated\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sat_prob-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.sat_prob","text":"sat_prob(root::LogicCircuit; varprob::Function)::Rational{BigInt}\n\nGet the probability that a random world satisties the circuit.  Probability of each variable is given by varprob Function which defauls to 1/2 for every variable.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_mgr_for-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.sdd_mgr_for","text":"Obtain an SDD manager that can support compiling the given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_num_nodes-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sdd_num_nodes","text":"Count the number of decision nodes in the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_size-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sdd_size","text":"Count the number of elements in the decision nodes of the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.smooth","text":"smooth(root::Node)::Node\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth_node-Tuple{Node,Any,Any}","page":"LogicCircuits","title":"LogicCircuits.smooth_node","text":"smooth_node(node::Node, missing_scope, lit_nodes)\n\nReturn a smooth version of the node where  the missing_scope variables are added to the scope, using literals from lit_nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.split_candidates-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.split_candidates","text":"split_candidates(circuit::Node)::Tuple{Vector{Tuple{Node, Node}}, Dict{Node, BitSet}}\n\nReturn the edges and variables which can be splited on\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.split_step-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.split_step","text":"Split step\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.struct_learn-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.struct_learn","text":"Structure learning manager\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sub-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sub","text":"Get the sub, that is, the second and last conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.tree_formula_string-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.tree_formula_string","text":"Get the formula of a given circuit as a string, expanding the formula into a tree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.unique⋁-Tuple{Array{LogicCircuits.Element,1},LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.unique⋁","text":"Construct a unique decision gate for the given vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable","page":"LogicCircuits","title":"LogicCircuits.variable","text":"Get the variable in a vtree leaf\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.variable","text":"Get the logical variable in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.variables_by_node-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.variables_by_node","text":"Get the variable scope of each node in the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset-Tuple{Vtree,Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset","text":"Are the variables in n contained in the variables in m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_left-Tuple{Vtree,Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset_left","text":"Are the variables in n contained in the left branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_right-Tuple{Vtree,Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset_right","text":"Are the variables in n contained in the right branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.vtree-Tuple{StructLogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.vtree","text":"Get the vtree corresponding to the argument\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.vtree_safe-Tuple{PlainStructLogicInnerNode}","page":"LogicCircuits","title":"LogicCircuits.vtree_safe","text":"Get the vtree corresponding to the argument, or nothing if the node has no vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.⋀_nodes","text":"Get the list of conjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.⋁_nodes","text":"Get the list of disjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#api-internal-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/internals/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/internals/utils/#LogicCircuits.Utils","page":"Utils","title":"LogicCircuits.Utils","text":"Module with general utilities and missing standard library features  that could be useful in any Julia project\n\n\n\n\n\n","category":"module"},{"location":"api/internals/utils/#LogicCircuits.Utils.Dag","page":"Utils","title":"LogicCircuits.Utils.Dag","text":"A node in a directed acyclic graph (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Inner","page":"Utils","title":"LogicCircuits.Utils.Inner","text":"The trait of inner nodes (nodes that have children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Leaf","page":"Utils","title":"LogicCircuits.Utils.Leaf","text":"The trait of leaf nodes (nodes without children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Lit","page":"Utils","title":"LogicCircuits.Utils.Lit","text":"Literals are represented as 32-bit signed integers. Positive literals are positive integers identical to their variable. Negative literals are their negations. Integer 0 should not be used to represent literals.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Node","page":"Utils","title":"LogicCircuits.Utils.Node","text":"A node in a directed graph. This type hierarchy is organized according  to the type of graph the node is part of.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"A trait hierarchy denoting types of Dag nodes NodeType defines an orthogonal type hierarchy of node types, so we can dispatch on node type regardless of the graph type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"Get the node type trait of the given Node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.Tree","page":"Utils","title":"LogicCircuits.Utils.Tree","text":"A node in a tree (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Var","page":"Utils","title":"LogicCircuits.Utils.Var","text":"Variables are represented as 32-bit unsigned integers\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#Base.filter-Union{Tuple{T}, Tuple{Function,Dag}, Tuple{Function,Dag,Type{T}}} where T","page":"Utils","title":"Base.filter","text":"Retrieve list of nodes in graph matching predicate p\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.foreach-Tuple{Function,Dag}","page":"Utils","title":"Base.foreach","text":"Apply a function to each node in a graph, bottom up\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.in-Tuple{Dag,Dag}","page":"Utils","title":"Base.in","text":"Is the node contained in the Dag?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.isdisjoint-Tuple{AbstractSet,AbstractSet,AbstractSet,Vararg{AbstractSet,N} where N}","page":"Utils","title":"Base.isdisjoint","text":"Are the given sets disjoint (no shared elements)?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.parent-Tuple{Tree}","page":"Utils","title":"Base.parent","text":"Get the parent of a given tree node (or nothing if the node is root)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#DataFrames.groupby-Union{Tuple{E}, Tuple{Function,Union{Set{E}, Array{E,1}}}} where E","page":"Utils","title":"DataFrames.groupby","text":"Group the elements of list by their values according to function f\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.always-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.always","text":"An array of 100% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.batch","page":"Utils","title":"LogicCircuits.Utils.batch","text":"Create mini-batches\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.bits_per_pixel-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.bits_per_pixel","text":"Normalize the given log-likelihood as bits per pixel in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.children","page":"Utils","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.clear_data-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.clear_data","text":"Set all the data fields in a circuit to nothing\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.count_parents-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.count_parents","text":"Set the counter field of each node to its number of parents\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.depth-Tuple{Tree,Function}","page":"Utils","title":"LogicCircuits.Utils.depth","text":"Compute the length of the path from a tree node to the leaf following the branching function\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.example-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.example","text":"Get the ith example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.feature_bitstrings-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.feature_bitstrings","text":"For binary data, retrieve it as a vector of bit strings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.feature_values-Tuple{DataFrames.DataFrame,Any}","page":"Utils","title":"LogicCircuits.Utils.feature_values","text":"Get the ith feature values\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.find_inode-Tuple{Any,Any,Function}","page":"Utils","title":"LogicCircuits.Utils.find_inode","text":"Find a binary inner node that has left in its left subtree and right in its right subtree. Supports nothing as a catch-all for either left or right. Returns nothing if no such node exists.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.find_leaf-Tuple{Tree,Function}","page":"Utils","title":"LogicCircuits.Utils.find_leaf","text":"Find the leaf in the tree by follwing the branching function\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{Dag,Function,Function,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup","text":"foldup(node::Dag, \n    f_leaf::Function, \n    f_inner::Function, \n    ::Type{T}; nload = nload, nsave = nsave, reset=true)::T where {T}\n\nCompute a function bottom-up on the graph.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup_rec-Union{Tuple{T}, Tuple{Dag,Function,Function,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup_rec","text":"Compute a function bottom-up on the graph, without resetting the counter.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_down-Tuple{Function,Dag}","page":"Utils","title":"LogicCircuits.Utils.foreach_down","text":"Apply a function to each node in a graph, top down\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_down_rec-Tuple{Function,Node}","page":"Utils","title":"LogicCircuits.Utils.foreach_down_rec","text":"Apply a function to each node in a graph, top down, without setting the counter first\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_rec-Tuple{Function,Dag}","page":"Utils","title":"LogicCircuits.Utils.foreach_rec","text":"Apply a function to each node in a graph, bottom up, without resetting the counter\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_reset-Tuple{Function,Dag}","page":"Utils","title":"LogicCircuits.Utils.foreach_reset","text":"Apply a function to each node in a graph, bottom up, while resetting the counter\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.fully_factorized_log_likelihood-Tuple{AbstractArray{var\"#s12\",2} where var\"#s12\"<:Bool}","page":"Utils","title":"LogicCircuits.Utils.fully_factorized_log_likelihood","text":"Computer the per-example log-likelihood of a fully factorized ML model on Bool data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.has_children","text":"Does the node have children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_parent-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.has_parent","text":"Does the node have a parent?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.init_array-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.init_array","text":"An array of undetermined values (fast) for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.innernodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.innernodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inode_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.inode_stats","text":"Give count of types and fan-ins of inner nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.inodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isbinarydata-Tuple{AbstractArray{T,2} where T}","page":"Utils","title":"LogicCircuits.Utils.isbinarydata","text":"Is the dataset binary?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isequal_local-Tuple{Tree,Tree}","page":"Utils","title":"LogicCircuits.Utils.isequal_local","text":"Is one node equal to another locally, ignoring children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isgpu-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.isgpu","text":"Check whether data resides on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isinner-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isinner","text":"Is the node an Inner node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isleaf-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isleaf","text":"Is the node a leaf node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isnumericdata-Tuple{AbstractArray{T,2} where T}","page":"Utils","title":"LogicCircuits.Utils.isnumericdata","text":"Is the dataset numeric?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isroot-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.isroot","text":"Is the node the root of its tree?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.issomething-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.issomething","text":"Is the argument not nothing?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lca-Tuple{Tree,Tree,Function}","page":"Utils","title":"LogicCircuits.Utils.lca","text":"Find the least common ancestor. Assumes the Tree has access to a parent.  A given descends_from function is required to quickly check whether a node is an ancestor.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leaf_stats-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.leaf_stats","text":"Give count of types of leaf nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leafnodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.leafnodes","text":"Get the list of leaf nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.left_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.left_most_descendent","text":"Return the left-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.linearize-Union{Tuple{Dag}, Tuple{T}, Tuple{Dag,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.linearize","text":"Order the Dag's nodes bottom-up in a list (with optional element type)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lit2var-Tuple{Int32}","page":"Utils","title":"LogicCircuits.Utils.lit2var","text":"Convert a literal its variable, removing the sign of the literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.ll_per_example-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.ll_per_example","text":"Normalize the given log-likelihood by the number of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.map_values-Union{Tuple{K}, Tuple{Function,AbstractDict{K,V} where V,Type}} where K","page":"Utils","title":"LogicCircuits.Utils.map_values","text":"Map the values in the dictionary, retaining the same keys\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.never-Union{Tuple{T}, Tuple{Type{T},Vararg{Int64,N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.never","text":"An array of 0% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.nload-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.nload","text":"Default getter to obtain data associated with a node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.node_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.node_stats","text":"Give count of types and fan-ins of all nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.noop-Tuple","page":"Utils","title":"LogicCircuits.Utils.noop","text":"Function that does nothing\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.nsave-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.nsave","text":"Default setter to assign data associated with a node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_bitstrings-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.num_bitstrings","text":"For binary data, how many bit strings are needed to store one feature?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.num_children","text":"Get the number of children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_edges-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_edges","text":"Number of edges in the Dag\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_examples-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_examples","text":"num_examples(df::DataFrame)\nnum_examples(m::AbstractMatrix)\n\nNumber of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_features-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_features","text":"num_features(df::DataFrame)\nnum_features(m::AbstractMatrix)\n\nNumber of features in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_nodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_nodes","text":"num_nodes(node::Dag)\n\nCount the number of nodes in the Dag\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_variables-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.num_variables","text":"Number of variables in the data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.number_precision-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.number_precision","text":"Find a number type that can capture all data points\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.order_asc-Tuple{Any,Any}","page":"Utils","title":"LogicCircuits.Utils.order_asc","text":"Order the arguments in a tuple in ascending order\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.print_tree","page":"Utils","title":"LogicCircuits.Utils.print_tree","text":"Print the given tree\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.pushrand!-Tuple{AbstractArray{var\"#s13\",1} where var\"#s13\",Any}","page":"Utils","title":"LogicCircuits.Utils.pushrand!","text":"Push element into random position in vectorv\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.reset_counter","page":"Utils","title":"LogicCircuits.Utils.reset_counter","text":"Set the counter field throughout this graph (assumes no node in the graph already has the value)\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.right_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.right_most_descendent","text":"Return the right-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.shuffle_examples-Tuple{Union{DataFrames.DataFrame, AbstractArray{T,2} where T}}","page":"Utils","title":"LogicCircuits.Utils.shuffle_examples","text":"shuffle_examples(df::DataFrame) \nshuffle_examples(m::AbstractMatrix)\n\nShuffle the examples in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.similar!-Union{Tuple{A}, Tuple{Any,Type{A},Vararg{Any,N} where N}} where A<:AbstractArray","page":"Utils","title":"LogicCircuits.Utils.similar!","text":"Reuse a given array if it has the right type and size, otherwise make a new one\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.soften","page":"Utils","title":"LogicCircuits.Utils.soften","text":"Turn binary data into floating point data close to 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.subseteq_fast-Tuple{BitSet,BitSet}","page":"Utils","title":"LogicCircuits.Utils.subseteq_fast","text":"Replacement for BitSet.⊆ that does not allocate a new BitSet\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.threshold-Tuple{Any,Any,Any}","page":"Utils","title":"LogicCircuits.Utils.threshold","text":"Threshold a numeric dataset making it binary\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.to_cpu-Tuple{AbstractArray}","page":"Utils","title":"LogicCircuits.Utils.to_cpu","text":"Move data to the CPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.to_gpu-Tuple{AbstractArray}","page":"Utils","title":"LogicCircuits.Utils.to_gpu","text":"Move data to the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_edges-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.tree_num_edges","text":"tree_num_edges(node::Dag)::BigInt\n\nCompute the number of edges in the tree-unfolding of the Dag. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_nodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.tree_num_nodes","text":"tree_num_nodes(node::Dag)::BigInt\n\nCompute the number of nodes in of a tree-unfolding of the Dag. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.uniform-Tuple{Vararg{Int64,N} where N}","page":"Utils","title":"LogicCircuits.Utils.uniform","text":"An array of uniform probabilities\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.var2lit-Tuple{UInt32}","page":"Utils","title":"LogicCircuits.Utils.var2lit","text":"Convert a variable to the corresponding positive literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.variables","page":"Utils","title":"LogicCircuits.Utils.variables","text":"Get the BitSet of variables in the data structure\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#StatsFuns.logsumexp-Tuple{AbstractArray,Any}","page":"Utils","title":"StatsFuns.logsumexp","text":"Marginalize out dimensions dims from log-probability tensor\n\n\n\n\n\n","category":"method"},{"location":"manual/properties/#man-structural-properties","page":"Structural Properties","title":"Structural Properties","text":"","category":"section"},{"location":"manual/properties/#Smoothness","page":"Structural Properties","title":"Smoothness","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same set of variables. ","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To checks whether a circuit is smooth (issmooth):","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nissmooth(lc)","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"As we see the circuit is not smooth. We can smooth the circuit using smooth:","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"smoothed_lc = smooth(lc)\nissmooth(smoothed_lc)","category":"page"},{"location":"manual/properties/#Determinism","page":"Structural Properties","title":"Determinism","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is deterministic if each of its OR nodes are deterministic. An OR node is deterministic if for every possible assignment to the variables, at most one of the its children can be active (true).","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To check for determinism, you can use isdeterministic. Note that checking determinisim required use of a SAT solver, and in general it is not tractable for big circuits.","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nisdeterministic(lc)","category":"page"},{"location":"manual/properties/#Decomposability","page":"Structural Properties","title":"Decomposability","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is decomposable if each of its AND nodes are decomposable.  An AND node is decomposable if for each pair of children the set of variables they depend on is disjoint.","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To checks whether a circuit is decomposable (isdecomposable):","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nisdecomposable(lc)","category":"page"},{"location":"manual/properties/#Structured-Decomposability","page":"Structural Properties","title":"Structured Decomposability","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"Structured decomposability is a stonger condition that decomposability. In addition of each AND node being decomposable, they have to decompose in a structured way which is determined by a vtree (variable tree). A vtree, is a binary tree where each leaf represents a variable and each internal node represents a way of decomposing the variables. ","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nvtree = load_vtree(zoo_vtree_file(\"random.vtree\"));\nrespects_vtree(lc, vtree)","category":"page"},{"location":"manual/transformations/#man-tranformations","page":"Tranformations","title":"Tranformations","text":"","category":"section"},{"location":"manual/transformations/#Conditioning","page":"Tranformations","title":"Conditioning","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, conditioning on the literal x (resp. lnot x) is equivalent to replacing every occurance of X with true (resp. false). ","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"(Delta mid x)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"For example, to condition on lnot x_2, you can use condition as follows:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nc2not = condition(lc, Lit(-2));\n\nnum_nodes(lc), num_nodes(c2not)","category":"page"},{"location":"manual/transformations/#Forgetting","page":"Tranformations","title":"Forgetting","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, forgetting the variable X can be thought of as erasing (forgetting) what the formula says about variable X:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta ","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Forgeting is also equivalent to disjunction of different ways to condition on X. The possible values for X are the literals x or lnot x, so we have:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta = (Delta mid x) lor (Delta mid lnot x)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"For example, to forget X_2 you can use forget as follows:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nf1 = forget(lc, (i) -> (i == 2));\n\nnum_variables(lc), num_variables(f1)","category":"page"},{"location":"manual/transformations/#Smoothing","page":"Tranformations","title":"Smoothing","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Smoothing is the act of converting a non-smooth circuit to a circuit representing the same formula that is smooth. A logic circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given a non-smooth circuit we can smooth it, for example:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"using LogicCircuits # hide\nlc = load_logic_circuit(zoo_sdd_file(\"random.sdd\"));\nsmooth_lc = smooth(lc)\n\nissmooth(lc), issmooth(smooth_lc)","category":"page"},{"location":"manual/transformations/#Apply","page":"Tranformations","title":"Apply","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given two logic circuits Delta_1, Delta_2, and a binary operation o the apply operation outputs a logic circuit representing:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 o Delta_2","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Note that, in addition to representing the correct formula, the apply operation also wants to preserve the structural properites of the circuits such as  determinism and decomposability.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"The major binary operations are conjunction (land), disjunction (lor), and XOR (oplus). There are 2^4 = 16 possible binary operations, 6 of which are trivial operations (such as always returning false or depending only on one of the circuits). The other 10 can be derived by combination of not operation (lnot) with the main 3 operations mentioned. The list of all possible non-trivial binary operations are below:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor lnot Delta_2 \n    Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land lnot Delta_2 \n    Delta_1 oplus Delta_2 lnot (Delta_1 oplus Delta_2) ","category":"page"},{"location":"#LogicCircuits.jl","page":"Home","title":"LogicCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LogicCircuits.jl module provides a Julia implementation of tools to represent boolean formulas, operate on them, and ask queries about them.    ","category":"page"},{"location":"#What-are-Logic-Circuits?","page":"Home","title":"What are Logic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each logic circuit represents a boolean formula.  Internally, they are structured as a DAG with leave nodes being constants (true, false) or literals (X, lnot X).  Internal nodes can be AND or OR nodes.  Note that negation can only be done at the leaves.  This representation of boolean formulas is also known as Negation Normal Form (NNF).  In general, we also want to enforce few other structural properties such as smoothness, determinism, decomposability to enable tractable logical reasoning. ","category":"page"},{"location":"#What-can-we-do-with-them?","page":"Home","title":"What can we do with them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given a logic circuit there are many questions that we can ask.  For example, we might want to see whether it is satisfiable (SAT),  how many different ways are there to satisfy it (model counting),  or check whether it is equivalent with another logic circuit.  We refer to these as queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On another front, we might want to operate on the logic circuits themselves.  For example, we might want to condition on a literal, forget a variable, conjoin or disjoin two circuits, or negate the circuit.  We refer to these tasks as transformations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, many of these tasks are intractable, however given different combinations of  properties on structure of logic circuits we can unlock different queries to become tractable.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the Manual section for more details on important concepts, and examples on how to use this module.","category":"page"}]
}
