var documenterSearchIndex = {"docs":
[{"location":"api/internals/logical/#api-internal-logical-1","page":"Logical","title":"Logical","text":"","category":"section"},{"location":"api/internals/logical/#","page":"Logical","title":"Logical","text":"Modules = [LogicCircuits.Logical]","category":"page"},{"location":"api/internals/logical/#LogicCircuits.Logical.ConstantGate","page":"Logical","title":"LogicCircuits.Logical.ConstantGate","text":"A trait denoting constant leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.ConstantNode","page":"Logical","title":"LogicCircuits.Logical.ConstantNode","text":"A logical constant leaf node, representing true or false\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.DecoratorΔ","page":"Logical","title":"LogicCircuits.Logical.DecoratorΔ","text":"Any circuit that has an origin represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.DecoratorΔNode","page":"Logical","title":"LogicCircuits.Logical.DecoratorΔNode","text":"A circuit node that has an origin of type O\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.DownFlowΔ-Union{Tuple{AbstractArray{#s37,1} where #s37<:UpFlowΔNode{O,F}}, Tuple{F}, Tuple{O}, Tuple{AbstractArray{#s37,1} where #s37<:UpFlowΔNode{O,F},Any}} where F where O","page":"Logical","title":"LogicCircuits.Logical.DownFlowΔ","text":"Construct a downward flow circuit from a given upward flow circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.FalseNode","page":"Logical","title":"LogicCircuits.Logical.FalseNode","text":"Constant False node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.FlowΔ-Union{Tuple{El}, Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int64,Type{El}}, Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int64,Type{El},Any}} where El","page":"Logical","title":"LogicCircuits.Logical.FlowΔ","text":"Construct a up and down flow circuit from a given other circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.GateType","page":"Logical","title":"LogicCircuits.Logical.GateType","text":"A trait hierarchy denoting types of nodes GateType defines an orthogonal type hierarchy of node types, not circuit types, so we can dispatch on node type regardless of circuit type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.GateType-Tuple{Type{#s36} where #s36<:LiteralNode}","page":"Logical","title":"LogicCircuits.Logical.GateType","text":"Returns GateType of a node (Literal, Constant, And, Or)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.Lit","page":"Logical","title":"LogicCircuits.Logical.Lit","text":"Literals are represented as 32-bit signed integers. Positive literals are positive integers identical to their variable. Negative literals are their negations. Integer 0 should not be used to represent literals.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.LiteralGate","page":"Logical","title":"LogicCircuits.Logical.LiteralGate","text":"A trait denoting literal leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.LiteralNode","page":"Logical","title":"LogicCircuits.Logical.LiteralNode","text":"A logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.LogicalLeafNode","page":"Logical","title":"LogicCircuits.Logical.LogicalLeafNode","text":"A logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.LogicalΔ","page":"Logical","title":"LogicCircuits.Logical.LogicalΔ","text":"A logical circuit represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.LogicalΔNode","page":"Logical","title":"LogicCircuits.Logical.LogicalΔNode","text":"Root of the logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.PlainVtreeNode","page":"Logical","title":"LogicCircuits.Logical.PlainVtreeNode","text":"Root of the plain vtree node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Sdd","page":"Logical","title":"LogicCircuits.Logical.Sdd","text":"A structured logical circuit represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddConstantNode","page":"Logical","title":"LogicCircuits.Logical.SddConstantNode","text":"A structured logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddLeafNode","page":"Logical","title":"LogicCircuits.Logical.SddLeafNode","text":"A SDD logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddLiteralNode","page":"Logical","title":"LogicCircuits.Logical.SddLiteralNode","text":"A SDD logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddMgrNode","page":"Logical","title":"LogicCircuits.Logical.SddMgrNode","text":"Root of the SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddNode","page":"Logical","title":"LogicCircuits.Logical.SddNode","text":"Root of the SDD circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Sdd⋀Node","page":"Logical","title":"LogicCircuits.Logical.Sdd⋀Node","text":"A structured logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Sdd⋁Node","page":"Logical","title":"LogicCircuits.Logical.Sdd⋁Node","text":"A structured logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructConstantNode","page":"Logical","title":"LogicCircuits.Logical.StructConstantNode","text":"A structured logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructLiteralNode","page":"Logical","title":"LogicCircuits.Logical.StructLiteralNode","text":"A structured logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructLogicalLeafNode","page":"Logical","title":"LogicCircuits.Logical.StructLogicalLeafNode","text":"A structured logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructLogicalΔ","page":"Logical","title":"LogicCircuits.Logical.StructLogicalΔ","text":"A structured logical circuit represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructLogicalΔNode","page":"Logical","title":"LogicCircuits.Logical.StructLogicalΔNode","text":"Root of the structure logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Struct⋀Node","page":"Logical","title":"LogicCircuits.Logical.Struct⋀Node","text":"A structured logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Struct⋁Node","page":"Logical","title":"LogicCircuits.Logical.Struct⋁Node","text":"A structured logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.TrimMgrNode","page":"Logical","title":"LogicCircuits.Logical.TrimMgrNode","text":"Root of the trimmed SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.TrueNode","page":"Logical","title":"LogicCircuits.Logical.TrueNode","text":"Constant True node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.UnstLogicalΔ","page":"Logical","title":"LogicCircuits.Logical.UnstLogicalΔ","text":"A unstructured logical circuit represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.UnstLogicalΔNode","page":"Logical","title":"LogicCircuits.Logical.UnstLogicalΔNode","text":"Root of the unstructured logical circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.UpFlowΔ-Union{Tuple{El}, Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int64,Type{El}}, Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int64,Type{El},Any}} where El","page":"Logical","title":"LogicCircuits.Logical.UpFlowΔ","text":"Construct a upward flow circuit from a given other circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.Var","page":"Logical","title":"LogicCircuits.Logical.Var","text":"Variables are represented as 32-bit unsigned integers\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.VtreeNode","page":"Logical","title":"LogicCircuits.Logical.VtreeNode","text":"Root of the vtree node hiearchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.Δ","page":"Logical","title":"LogicCircuits.Logical.Δ","text":"Any circuit represented as a bottom-up linear order of nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.ΔNode","page":"Logical","title":"LogicCircuits.Logical.ΔNode","text":"Root of the circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋀Gate","page":"Logical","title":"LogicCircuits.Logical.⋀Gate","text":"A trait denoting conjuction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋀Node","page":"Logical","title":"LogicCircuits.Logical.⋀Node","text":"A logical conjunction node (And node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋁Gate","page":"Logical","title":"LogicCircuits.Logical.⋁Gate","text":"A trait denoting disjunction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋁Node","page":"Logical","title":"LogicCircuits.Logical.⋁Node","text":"A logical disjunction node (Or node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#Base.split-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode},Tuple{ΔNode,ΔNode},UInt32}","page":"Logical","title":"Base.split","text":"Return the circuit after spliting on edge edge and variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.and_nodes-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.and_nodes","text":"Get the list of And nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.balanced_vtree-Union{Tuple{VN}, Tuple{Type{VN},Int64}} where VN<:VtreeNode","page":"Logical","title":"LogicCircuits.Logical.balanced_vtree","text":"Construct a balanced vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.bottom_up_vtree-Union{Tuple{VN}, Tuple{Type{VN},Array{UInt32,1},Function}} where VN<:VtreeNode","page":"Logical","title":"LogicCircuits.Logical.bottom_up_vtree","text":"Construct PlainVtree bottom up, using method specified by combine_method!.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.canonicalize-Tuple{Set{Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}}}","page":"Logical","title":"LogicCircuits.Logical.canonicalize","text":"Get the canonical compilation of the given XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.clone-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode},ΔNode,ΔNode,ΔNode}","page":"Logical","title":"LogicCircuits.Logical.clone","text":"Clone the and node and redirect one of its parents to the new copy\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.compile-Tuple{AbstractArray{#s37,1} where #s37<:TrimMgrNode,Union{Int32, UInt32}}","page":"Logical","title":"LogicCircuits.Logical.compile","text":"Compile a given variable, literal, or constant\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.compress-Tuple{Set{Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}}}","page":"Logical","title":"LogicCircuits.Logical.compress","text":"Compress a given XY Partition (merge elements with identical subs)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.condition-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int32}","page":"Logical","title":"LogicCircuits.Logical.condition","text":"Return the circuit conditioned on given constrains\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin-Tuple{LogicCircuits.Logical.SddFalseNode{TrimMgrNode},LogicCircuits.Logical.SddTrueNode{TrimMgrNode}}","page":"Logical","title":"LogicCircuits.Logical.conjoin","text":"Conjoin two SDDs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.constant-Tuple{TrueNode}","page":"Logical","title":"LogicCircuits.Logical.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.constant-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin-Tuple{LogicCircuits.Logical.SddFalseNode{TrimMgrNode},LogicCircuits.Logical.SddTrueNode{TrimMgrNode}}","page":"Logical","title":"LogicCircuits.Logical.disjoin","text":"Disjoin two SDDs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.false_like-Tuple{Any}","page":"Logical","title":"LogicCircuits.Logical.false_like","text":"Construct a false node in the hierarchy of node n\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.forget-Tuple{Function,AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.forget","text":"Forget variables from the circuit.  Warning: this may or may not destroy the determinism property.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.fully_factorized_circuit-Tuple{Any}","page":"Logical","title":"LogicCircuits.Logical.fully_factorized_circuit","text":"Generate a fully factorized (logistic regression) circuit over n variables\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.grand_origin-Tuple{AbstractArray{#s37,1} where #s37<:DecoratorΔNode{O} where O}","page":"Logical","title":"LogicCircuits.Logical.grand_origin","text":"Get the origin of the origin the given decorator circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.grand_origin-Union{Tuple{DecoratorΔNode{#s36} where #s36<:DecoratorΔNode{O}}, Tuple{O}} where O","page":"Logical","title":"LogicCircuits.Logical.grand_origin","text":"Get the origin of the origin of the given decorator circuit node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.has_unique_constant_nodes-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.has_unique_constant_nodes","text":"Check whether constant nodes are unique\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.has_unique_literal_nodes-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.has_unique_literal_nodes","text":"Check whether literal nodes are unique\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.is_decomposable-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.is_decomposable","text":"Is the circuit decomposable?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.is_false-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.is_false","text":"Is the circuit syntactically equal to false?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.is_smooth-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.is_smooth","text":"Is the circuit smooth?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.is_true-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.is_true","text":"Is the circuit syntactically equal to true?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.lit2var-Tuple{Int32}","page":"Logical","title":"LogicCircuits.Logical.lit2var","text":"Convert a literal its variable, removing the sign of the literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.literal-Tuple{LiteralNode}","page":"Logical","title":"LogicCircuits.Logical.literal","text":"Get the logical literal in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.literal-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.literal","text":"Get the logical literal in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.model_count","page":"Logical","title":"LogicCircuits.Logical.model_count","text":"Get the model count of the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logical/#LogicCircuits.Logical.negate-Tuple{LogicCircuits.Logical.SddFalseNode{TrimMgrNode}}","page":"Logical","title":"LogicCircuits.Logical.negate","text":"Negate an SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.node_type-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.node_type","text":"Get the node type at the root of the corresponding hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.num_variables-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.num_variables","text":"Number of variables in the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.or_nodes-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.or_nodes","text":"Get the list of or nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.origin-Tuple{AbstractArray{#s37,1} where #s37<:DecoratorΔNode{O} where O}","page":"Logical","title":"LogicCircuits.Logical.origin","text":"Get the origin of the given decorator circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.origin-Union{Tuple{DecoratorΔNode{O}}, Tuple{O}} where O<:ΔNode","page":"Logical","title":"LogicCircuits.Logical.origin","text":"Get the origin of the given decorator circuit node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.origin-Union{Tuple{O}, Tuple{DecoratorΔNode{#s36} where #s36<:O,Type{O}}} where O<:ΔNode","page":"Logical","title":"LogicCircuits.Logical.origin","text":"Get the first origin of the given decorator circuit node of the given type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.origin-Union{Tuple{T}, Tuple{AbstractArray{#s37,1} where #s37<:DecoratorΔNode{O} where O,Type{T}}} where T","page":"Logical","title":"LogicCircuits.Logical.origin","text":"Get the first origin of the given decorator circuit of the given node type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.path_length-Tuple{VtreeNode,UInt32}","page":"Logical","title":"LogicCircuits.Logical.path_length","text":"Return the length from vtree inner node n to leaf node which contains var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.positive-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.positive","text":"Get the sign of the literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.prob_equiv_signature-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode,Int64}","page":"Logical","title":"LogicCircuits.Logical.prob_equiv_signature","text":"Get a signature for each node using probabilistic equivalence checking\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.propagate_constants-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.propagate_constants","text":"Remove all constant leafs from the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.sat_prob-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.sat_prob","text":"Get the probability that a random world satisties the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.smooth-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.smooth","text":"Create an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.top_down_vtree-Union{Tuple{VN}, Tuple{Type{VN},Array{UInt32,1},Function}} where VN<:VtreeNode","page":"Logical","title":"LogicCircuits.Logical.top_down_vtree","text":"Construct PlainVtree top town, using method specified by split_method.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.true_like-Tuple{Any}","page":"Logical","title":"LogicCircuits.Logical.true_like","text":"Construct a true node in the hierarchy of node n\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.unique⋁","page":"Logical","title":"LogicCircuits.Logical.unique⋁","text":"Construct a unique decision gate for the given vtree\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logical/#LogicCircuits.Logical.var2lit-Tuple{UInt32}","page":"Logical","title":"LogicCircuits.Logical.var2lit","text":"Convert a variable to the corresponding positive literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.variable-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.variable","text":"Get the logical variable in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.variable_scope-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.variable_scope","text":"Get the variable scope of the circuit node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.variable_scope-Tuple{ΔNode}","page":"Logical","title":"LogicCircuits.Logical.variable_scope","text":"Get the variable scope of the root of the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.variable_scopes-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.variable_scopes","text":"Get the variable scope of each node in the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋀_nodes-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.⋀_nodes","text":"Get the list of conjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.⋁_nodes-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.⋁_nodes","text":"Get the list of disjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.LogicalInnerNode","page":"Logical","title":"LogicCircuits.Logical.LogicalInnerNode","text":"A logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.SddInnerNode","page":"Logical","title":"LogicCircuits.Logical.SddInnerNode","text":"A SDD logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.StructLogicalInnerNode","page":"Logical","title":"LogicCircuits.Logical.StructLogicalInnerNode","text":"A structured logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logical/#LogicCircuits.Logical.balanced_vtree_root-Union{Tuple{VN}, Tuple{Type{VN},Int64,Int64}} where VN","page":"Logical","title":"LogicCircuits.Logical.balanced_vtree_root","text":"Construct a balanced vtree root node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.canonicalize_compressed-Tuple{Set{Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}}}","page":"Logical","title":"LogicCircuits.Logical.canonicalize_compressed","text":"Get the canonical compilation of the given compressed XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin_cartesian-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.conjoin_cartesian","text":"Conjoin two SDDs when they respect the same vtree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin_descendent-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.conjoin_descendent","text":"Conjoin two SDDs when one descends from the other\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin_indep-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.conjoin_indep","text":"Conjoin two SDDs in separate parts of the vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin_like-Tuple{StructLogicalΔNode,Array{T,1} where T}","page":"Logical","title":"LogicCircuits.Logical.conjoin_like","text":"Conjoin nodes in the same way as the example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.conjoin_like-Tuple{ΔNode,Vararg{ΔNode,N} where N}","page":"Logical","title":"LogicCircuits.Logical.conjoin_like","text":"Conjoin nodes in the same way as the example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.constant_nodes-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.constant_nodes","text":"Construct a mapping from constants to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.constant_nodes2-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.constant_nodes2","text":"Construct a mapping from constants to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_cartesian-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.disjoin_cartesian","text":"Disjoin two SDDs when they respect the same vtree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_descendent-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.disjoin_descendent","text":"Disjoin two SDDs when one descends from the other\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_indep-Tuple{SddNode{#s37} where #s37<:TrimMgrNode,SddNode{#s37} where #s37<:TrimMgrNode}","page":"Logical","title":"LogicCircuits.Logical.disjoin_indep","text":"Disjoin two SDDs in separate parts of the vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_like-Tuple{StructLogicalΔNode,Array{T,1} where T}","page":"Logical","title":"LogicCircuits.Logical.disjoin_like","text":"Disjoin nodes in the same way as the example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_like-Tuple{UnstLogicalΔNode,Array{T,1} where T}","page":"Logical","title":"LogicCircuits.Logical.disjoin_like","text":"Disjoin nodes in the same way as the example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.disjoin_like-Tuple{ΔNode,Vararg{ΔNode,N} where N}","page":"Logical","title":"LogicCircuits.Logical.disjoin_like","text":"Disjoin nodes in the same way as the example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.has_unique_literal_nodes2-Tuple{AbstractArray{#s37,1} where #s37<:ΔNode}","page":"Logical","title":"LogicCircuits.Logical.has_unique_literal_nodes2","text":"Check whether literal nodes are unique\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.isvalid-Tuple{VtreeNode}","page":"Logical","title":"LogicCircuits.Logical.isvalid","text":"Check vtree validation, variables(parent) = variables(left) + variables(right)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.literal_like-Tuple{StructLogicalΔNode,Int32}","page":"Logical","title":"LogicCircuits.Logical.literal_like","text":"Construct a new literal node like the given node's type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.literal_like-Tuple{UnstLogicalΔNode,Int32}","page":"Logical","title":"LogicCircuits.Logical.literal_like","text":"Construct a new literal node like the given node's type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.literal_nodes-Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode}}","page":"Logical","title":"LogicCircuits.Logical.literal_nodes","text":"Construct a mapping from literals to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Logical.smooth_node-Tuple{ΔNode,Any,Any}","page":"Logical","title":"LogicCircuits.Logical.smooth_node","text":"Return a smooth version of the node where the missing_scope variables are added to the scope, using literals from lit_nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Utils.children-Tuple{LogicCircuits.Logical.LogicalInnerNode}","page":"Logical","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode},Function,Function,Function,Function,Type{T}}} where T","page":"Logical","title":"LogicCircuits.Utils.foldup","text":"Compute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{Union{ΔNode, AbstractArray{#s37,1} where #s37<:ΔNode},Function,Function,Function,Function,Type{T}}} where T","page":"Logical","title":"LogicCircuits.Utils.foldup_aggregate","text":"Compute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logical/#LogicCircuits.Utils.isequal_local-Tuple{PlainVtreeNode,PlainVtreeNode}","page":"Logical","title":"LogicCircuits.Utils.isequal_local","text":"Compare whether two vtree nodes are locally equal (enables equals and equals_unordered from Utils)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#api-internal-data-1","page":"Data","title":"Data","text":"","category":"section"},{"location":"api/internals/data/#","page":"Data","title":"Data","text":"Modules = [Data]","category":"page"},{"location":"api/internals/data/#LogicCircuits.Data.AbstractData","page":"Data","title":"LogicCircuits.Data.AbstractData","text":"Any form of data where features are of type X\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.BatchedXDataset","page":"Data","title":"LogicCircuits.Data.BatchedXDataset","text":"Batches of unlabeled data with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.BatchedXYDataset","page":"Data","title":"LogicCircuits.Data.BatchedXYDataset","text":"Batches of labeled data with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.Dataset","page":"Data","title":"LogicCircuits.Data.Dataset","text":"A dataset with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.LabeledDataset","page":"Data","title":"LogicCircuits.Data.LabeledDataset","text":"A labeled dataset with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.PlainXData","page":"Data","title":"LogicCircuits.Data.PlainXData","text":"Unlabeled data (X-values) with a direct matrix representation\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.UnlabeledDataset","page":"Data","title":"LogicCircuits.Data.UnlabeledDataset","text":"An unlabeled dataset with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.WXData","page":"Data","title":"LogicCircuits.Data.WXData","text":"Unlabeled data (X-values) with weights for each example\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XBatches","page":"Data","title":"LogicCircuits.Data.XBatches","text":"Batches of unlabeled XData\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XData","page":"Data","title":"LogicCircuits.Data.XData","text":"Abstract unlabeled data (X-values)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XDataset","page":"Data","title":"LogicCircuits.Data.XDataset","text":"An single unlabeled dataset with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XYBatches","page":"Data","title":"LogicCircuits.Data.XYBatches","text":"Batches of labeled XYData\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XYData","page":"Data","title":"LogicCircuits.Data.XYData","text":"Labeled data (X-values with Y-labels)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.XYDataset","page":"Data","title":"LogicCircuits.Data.XYDataset","text":"An single labeled dataset with train/validation/test splits\n\n\n\n\n\n","category":"type"},{"location":"api/internals/data/#LogicCircuits.Data.aggr_weight_type-Tuple{Any}","page":"Data","title":"LogicCircuits.Data.aggr_weight_type","text":"What type should instance weights aggregate to?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.feature_data-Tuple{XYData}","page":"Data","title":"LogicCircuits.Data.feature_data","text":"Get the unlabeled feature portion of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.feature_matrix-Tuple{XData}","page":"Data","title":"LogicCircuits.Data.feature_matrix","text":"Get the data as a feature matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.feature_type-Union{Tuple{Type{#s36} where #s36<:AbstractData{X}}, Tuple{X}} where X","page":"Data","title":"LogicCircuits.Data.feature_type","text":"Get the type of the feature matrix elements\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.label_type-Union{Tuple{XYData{X,Y,XD,V} where V<:(AbstractArray{#s13,1} where #s13<:Y) where XD<:(XData{#s14,M} where M<:(AbstractArray{#s141,2} where #s141<:#s14) where #s14<:X)}, Tuple{Y}, Tuple{X}} where Y where X","page":"Data","title":"LogicCircuits.Data.label_type","text":"Get the type of the label vector elements\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.labels-Tuple{XYData}","page":"Data","title":"LogicCircuits.Data.labels","text":"Get the label vector of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.max_batch_size-Tuple{Union{XData, XYData}}","page":"Data","title":"LogicCircuits.Data.max_batch_size","text":"Size of the largest batch\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.num_batches-Tuple{Union{AbstractArray{#s14,1} where #s14<:XD where XD<:(XData{X,M} where M<:(AbstractArray{#s14,2} where #s14<:X)) where X, AbstractArray{#s14,1} where #s14<:XYD where XYD<:(XYData{X,Y,XD,V} where V<:(AbstractArray{#s13,1} where #s13<:Y) where XD<:(XData{#s14,M} where M<:(AbstractArray{#s141,2} where #s141<:#s14) where #s14<:X)) where Y where X}}","page":"Data","title":"LogicCircuits.Data.num_batches","text":"Number of batches in the dataset\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.num_examples-Tuple{Nothing}","page":"Data","title":"LogicCircuits.Data.num_examples","text":"Number of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.num_features-Tuple{WXData}","page":"Data","title":"LogicCircuits.Data.num_features","text":"Number of features in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.num_labels-Tuple{XYData}","page":"Data","title":"LogicCircuits.Data.num_labels","text":"Number of labels in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.test-Tuple{Dataset}","page":"Data","title":"LogicCircuits.Data.test","text":"Get the testing fold of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.total_example_weight-Tuple{Nothing}","page":"Data","title":"LogicCircuits.Data.total_example_weight","text":"Count the number of example in a weighted dataset\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.train-Tuple{Dataset}","page":"Data","title":"LogicCircuits.Data.train","text":"Get the training fold of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.unweighted_data-Tuple{PlainXData}","page":"Data","title":"LogicCircuits.Data.unweighted_data","text":"Get the data as plain unweighted data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.valid-Tuple{Dataset}","page":"Data","title":"LogicCircuits.Data.valid","text":"Get the validation fold of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.vslice-Tuple{PlainXData,Any,Any}","page":"Data","title":"LogicCircuits.Data.vslice","text":"Get slices of data (rows and columns ids) as a view (no memory allocation)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.weights-Tuple{WXData}","page":"Data","title":"LogicCircuits.Data.weights","text":"Get the weight vector of the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.replace_features-Union{Tuple{M}, Tuple{PlainXData,M}} where M","page":"Data","title":"LogicCircuits.Data.replace_features","text":"Replace the feature matrix in data by a given matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internals/data/#LogicCircuits.Data.unslice-Union{Tuple{Array{PlainXData{X,M},1}}, Tuple{M}, Tuple{X}} where M where X","page":"Data","title":"LogicCircuits.Data.unslice","text":"Undo batch operation, combine batches into one\n\n\n\n\n\n","category":"method"},{"location":"installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites-1","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia 1.3 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-LogicCircuits-1","page":"Installation","title":"Installing LogicCircuits","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line-1","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"LogicCircuits\")'","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install the package with the latest commits on master branch, run:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"))'","category":"page"},{"location":"installation/#From-Julia-Pkg-REPL-1","page":"Installation","title":"From Julia Pkg REPL","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"add LogicCircuits","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"add LogicCircuits#master","category":"page"},{"location":"installation/#Testing-1","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"LogicCircuits\")'","category":"page"},{"location":"api/public/#api-public-1","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"Documentation for LogicCircuits.jl's public interface.","category":"page"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"api/public/#Contents-1","page":"Public API","title":"Contents","text":"","category":"section"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Index-1","page":"Public API","title":"Index","text":"","category":"section"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Public-Interface-1","page":"Public API","title":"Public Interface","text":"","category":"section"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"load_logical_circuit\nload_smooth_logical_circuit","category":"page"},{"location":"api/public/#LogicCircuits.IO.load_logical_circuit","page":"Public API","title":"LogicCircuits.IO.load_logical_circuit","text":"Load a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.IO.load_smooth_logical_circuit","page":"Public API","title":"LogicCircuits.IO.load_smooth_logical_circuit","text":"Load a smooth logical circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"function"},{"location":"api/public/#","page":"Public API","title":"Public API","text":"note: Note\nThis list is not complete yet, will be adding more here as the public API gets finalized.","category":"page"},{"location":"manual/examples/#man-examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/examples/#","page":"Examples","title":"Examples","text":"note: Note\nMore examples coming soon, for now please refer to the Juice Examples Repository","category":"page"},{"location":"manual/queries/#man-queries-1","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"note: Note\nThis page is still under construction. For suggestions and fixes, please click on the \"Edit on Github\" button in the top right.","category":"page"},{"location":"manual/queries/#Evaluation-1","page":"Queries","title":"Evaluation","text":"","category":"section"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"Given a logical circuit Delta and an assignment to its variable, we would like to know the output of the circuit. For example, if Delta = X land Y, and we assign x, lnot y:","category":"page"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"X land Y = texttrue land textfalse = textfalse","category":"page"},{"location":"manual/queries/#Satisfiability-1","page":"Queries","title":"Satisfiability","text":"","category":"section"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"Given a logical circuit Delta, the goal of SAT is to answer whether there is an assignment to its variables such that the output is true. Depending on the structural properties of the logical circuit this problem can be intractable or tractable.","category":"page"},{"location":"manual/queries/#Model-Counting-1","page":"Queries","title":"Model Counting","text":"","category":"section"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"Given a logical circuit Delta, the goal of model counting is to count how many ways there are to assign values to variables of Delta such that the output of the circuit is true. ","category":"page"},{"location":"manual/queries/#Equivalence-Checking-1","page":"Queries","title":"Equivalence Checking","text":"","category":"section"},{"location":"manual/queries/#","page":"Queries","title":"Queries","text":"Given two logical circuits Delta_1 and Delta_2, the goal is to check whether these two circuits represent the same formula. There are both determnistic and probabilistic algorithms for this task.","category":"page"},{"location":"api/internals/io/#api-internal-io-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"api/internals/io/#","page":"IO","title":"IO","text":"Modules = [LogicCircuits.IO]","category":"page"},{"location":"api/internals/io/#LogicCircuits.IO.load_logical_circuit-Tuple{String}","page":"IO","title":"LogicCircuits.IO.load_logical_circuit","text":"Load a logical circuit from file. Support file formats:\n\n\".sdd\" for SDD files\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.load_smooth_logical_circuit-Tuple{String}","page":"IO","title":"LogicCircuits.IO.load_smooth_logical_circuit","text":"Load a smooth logical circuit from file. Support file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.load_struct_smooth_logical_circuit-Tuple{String,String}","page":"IO","title":"LogicCircuits.IO.load_struct_smooth_logical_circuit","text":"Load a smooth structured logical circuit from file. Support circuit file formats:\n\n\".psdd\" for PSDD files\n\".circuit\" for Logistic Circuit files\n\nSupported vtree file formats:\n\n\".vtree\" for VTree files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.save-Tuple{AbstractArray{#s37,1} where #s37<:PlainVtreeNode,AbstractString}","page":"IO","title":"LogicCircuits.IO.save","text":"Saves a vtree in the given file path.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.save_circuit-Tuple{String,AbstractArray{#s37,1} where #s37<:StructLogicalΔNode{V} where V,AbstractArray{#s37,1} where #s37<:PlainVtreeNode}","page":"IO","title":"LogicCircuits.IO.save_circuit","text":"Save a circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.BiasLine","page":"IO","title":"LogicCircuits.IO.BiasLine","text":"A line representing a bias node in the circuit (an OR with one child)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.CircuitCommentLine","page":"IO","title":"LogicCircuits.IO.CircuitCommentLine","text":"A string comment line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.CircuitFormatLine","page":"IO","title":"LogicCircuits.IO.CircuitFormatLine","text":"A parsed circuit file format line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.CircuitFormatLines","page":"IO","title":"LogicCircuits.IO.CircuitFormatLines","text":"A file consisting for circuit formal lines\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.CircuitHeaderLine","page":"IO","title":"LogicCircuits.IO.CircuitHeaderLine","text":"A header line for circuit files\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.ConstantLine","page":"IO","title":"LogicCircuits.IO.ConstantLine","text":"A line representing either the true or false logical constants\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.DecisionLine","page":"IO","title":"LogicCircuits.IO.DecisionLine","text":"A line representing a decision node in the circuit (an OR of AND elements)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.Element","page":"IO","title":"LogicCircuits.IO.Element","text":"Paired boxes, or elements, are conjunctions  in a larger decision node line\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.ID","page":"IO","title":"LogicCircuits.IO.ID","text":"Circuit and vtree node ids used for IO\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.InnerCircuitLine","page":"IO","title":"LogicCircuits.IO.InnerCircuitLine","text":"A circuit format line with child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.LeafCircuitLine","page":"IO","title":"LogicCircuits.IO.LeafCircuitLine","text":"A circuit format line without child IDs\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.LiteralLine","page":"IO","title":"LogicCircuits.IO.LiteralLine","text":"A line that represents a logical literal\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.UnweightedLiteralLine","page":"IO","title":"LogicCircuits.IO.UnweightedLiteralLine","text":"A line representing a single literal without parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.VtreeAbstractFile","page":"IO","title":"LogicCircuits.IO.VtreeAbstractFile","text":"Used to specify file type .vtree or .dot\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.VtreeFormatLine","page":"IO","title":"LogicCircuits.IO.VtreeFormatLine","text":"A line in one vtree file format\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.WeightedLiteralLine","page":"IO","title":"LogicCircuits.IO.WeightedLiteralLine","text":"A line representing a weighted single literal (for example a logistic circuit literal).\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.WeightedNamedConstantLine","page":"IO","title":"LogicCircuits.IO.WeightedNamedConstantLine","text":"A weighted constant line for a known variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/io/#LogicCircuits.IO.compile_logical-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_logical","text":"Compile lines into a unstructured logical circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_logical_m-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_logical_m","text":"Compile lines into a unstructured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_smooth_logical-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_smooth_logical","text":"Compile lines into a smooth unstructured logical circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_smooth_logical_m-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_smooth_logical_m","text":"Compile lines into a smooth unstructured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_smooth_struct_logical-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine,AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.VtreeFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_smooth_struct_logical","text":"Compile circuit and vtree lines into a structured logical circuit with its vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_smooth_struct_logical_m-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine,AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.VtreeFormatLine}","page":"IO","title":"LogicCircuits.IO.compile_smooth_struct_logical_m","text":"Compile circuit and vtree lines into a structured logical circuit with its vtree,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.compile_smooth_struct_logical_m-Tuple{AbstractArray{#s37,1} where #s37<:LogicCircuits.IO.CircuitFormatLine,Dict{UInt32,PlainVtreeNode}}","page":"IO","title":"LogicCircuits.IO.compile_smooth_struct_logical_m","text":"Compile circuit lines and vtree node mapping into a structured logical circuit,  while keeping track of id-to-node mappings\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.decompile-Tuple{StructLiteralNode,Any,Any}","page":"IO","title":"LogicCircuits.IO.decompile","text":"Decompile for sdd circuit, used during saving of circuits to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.load_cnf-Tuple{String}","page":"IO","title":"LogicCircuits.IO.load_cnf","text":"Load a CNF as a logical circuit from file. Supppor file formats:\n\n\".cnf\" for CNF files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.load_dnf-Tuple{String}","page":"IO","title":"LogicCircuits.IO.load_dnf","text":"Load a CNF as a logical circuit from file. Supppor file formats:\n\n\".cnf\" for CNF files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.save_sdd_file-Tuple{String,AbstractArray{#s37,1} where #s37<:StructLogicalΔNode{V} where V,AbstractArray{#s37,1} where #s37<:PlainVtreeNode}","page":"IO","title":"LogicCircuits.IO.save_sdd_file","text":"Save a SDD circuit to file\n\n\n\n\n\n","category":"method"},{"location":"api/internals/io/#LogicCircuits.IO.sdd_header-Tuple{}","page":"IO","title":"LogicCircuits.IO.sdd_header","text":"Returns header for SDD file format\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#api-internal-utils-1","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/internals/utils/#","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/internals/utils/#LogicCircuits.Utils","page":"Utils","title":"LogicCircuits.Utils","text":"Module with general utilities and missing standard library features that could be useful in any Julia project\n\n\n\n\n\n","category":"module"},{"location":"api/internals/utils/#Base.typejoin-Tuple{AbstractArray}","page":"Utils","title":"Base.typejoin","text":"Get the most specific type parameter possible for an array\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.copy_with_eltype-Tuple{Any,Type}","page":"Utils","title":"LogicCircuits.Utils.copy_with_eltype","text":"Copy the array while changing the element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.flip_bit-Union{Tuple{DagNode}, Tuple{Bit}, Tuple{DagNode,Val{Bit}}} where Bit","page":"Utils","title":"LogicCircuits.Utils.flip_bit","text":"Flip the bit field throughout this circuit (or ensure it is set to given value)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{AbstractArray{#s14,1} where #s14<:DagNode,Function,Function,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup","text":"Compute a function bottom-up on the circuit.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{AbstractArray{#s14,1} where #s14<:DagNode,Function,Function,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup_aggregate","text":"Compute a function bottom-up on the circuit.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner in aggregate as a vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.grapheltype-Tuple{AbstractArray{#s14,1} where #s14<:Node}","page":"Utils","title":"LogicCircuits.Utils.grapheltype","text":"Get the type of node contained in this graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.has_children","text":"Does the node have children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.innernodes-Tuple{Union{DagNode, AbstractArray{#s14,1} where #s14<:Node}}","page":"Utils","title":"LogicCircuits.Utils.innernodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inode_stats-Tuple{Union{DagNode, AbstractArray{#s14,1} where #s14<:Node}}","page":"Utils","title":"LogicCircuits.Utils.inode_stats","text":"Give count of types and fan-ins of inner nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inodes-Tuple{Union{DagNode, AbstractArray{#s14,1} where #s14<:Node}}","page":"Utils","title":"LogicCircuits.Utils.inodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isequal_local","page":"Utils","title":"LogicCircuits.Utils.isequal_local","text":"Is one node equal to another locally, ignoring children?\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.isequal_unordered-Tuple{AbstractArray{#s14,1} where #s14<:TreeNode,AbstractArray{#s14,1} where #s14<:TreeNode}","page":"Utils","title":"LogicCircuits.Utils.isequal_unordered","text":"Is one unordered tree equal to another?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isinner-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isinner","text":"Is the node an Inner node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isleaf-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isleaf","text":"Is the node a leaf node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.issomething-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.issomething","text":"Is the argument not nothing?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lca-Tuple{DagNode}","page":"Utils","title":"LogicCircuits.Utils.lca","text":"Find the least common ancestor (assumes the graph has a parent pointer and a list of descendents)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leaf_stats-Tuple{Union{DagNode, AbstractArray{#s14,1} where #s14<:Node}}","page":"Utils","title":"LogicCircuits.Utils.leaf_stats","text":"Give count of types of leaf nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leafnodes-Tuple{AbstractArray{#s14,1} where #s14<:Node}","page":"Utils","title":"LogicCircuits.Utils.leafnodes","text":"Get the list of leaf nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.left_most_child-Tuple{DagNode}","page":"Utils","title":"LogicCircuits.Utils.left_most_child","text":"Return the leftmost child.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lower_element_type-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T","page":"Utils","title":"LogicCircuits.Utils.lower_element_type","text":"Specialize the type parameter of an array to be most specific\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.node2dag-Union{Tuple{DagNode}, Tuple{T}, Tuple{DagNode,Type{T}}} where T","page":"Utils","title":"LogicCircuits.Utils.node2dag","text":"Rebuild a DAG's linear bottom-up order from a new root node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.node_stats-Tuple{Union{DagNode, AbstractArray{#s14,1} where #s14<:Node}}","page":"Utils","title":"LogicCircuits.Utils.node_stats","text":"Give count of types and fan-ins of all nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.num_children","text":"Get the number of children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_edges-Tuple{AbstractArray{#s14,1} where #s14<:Node}","page":"Utils","title":"LogicCircuits.Utils.num_edges","text":"Number of edges in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_nodes-Tuple{AbstractArray{#s14,1} where #s14<:Node}","page":"Utils","title":"LogicCircuits.Utils.num_nodes","text":"Number of nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.pushrand!-Tuple{AbstractArray{#s13,1} where #s13,Any}","page":"Utils","title":"LogicCircuits.Utils.pushrand!","text":"Push element into random position\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.right_most_child-Tuple{DagNode}","page":"Utils","title":"LogicCircuits.Utils.right_most_child","text":"Return the rightmost child.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_nodes-Tuple{AbstractArray{#s14,1} where #s14<:DagNode}","page":"Utils","title":"LogicCircuits.Utils.tree_num_nodes","text":"Compute the number of nodes in of a tree-unfolding of the DAG. \n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#StatsFuns.logsumexp-Tuple{AbstractArray,Any}","page":"Utils","title":"StatsFuns.logsumexp","text":"Marginalize out dimensions dims from log-probability tensor\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.Downpass","page":"Utils","title":"LogicCircuits.Utils.Downpass","text":"Compute a function top down on the circuit. f_root is called on the root node, f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed down the circuit and given to f_inner as a value from the parent.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#Base.filter-Union{Tuple{T}, Tuple{Function,DagNode}, Tuple{Function,DagNode,Type{T}}} where T","page":"Utils","title":"Base.filter","text":"Retrieve list of nodes in circuit matching predicate p\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.foreach-Tuple{Function,DagNode}","page":"Utils","title":"Base.foreach","text":"Apply a function to each node in a circuit, bottom up\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.isequal-Tuple{AbstractArray{#s14,1} where #s14<:TreeNode,AbstractArray{#s14,1} where #s14<:TreeNode}","page":"Utils","title":"Base.isequal","text":"Is one ordered tree equal to another?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.expand_product-Union{Tuple{E}, Tuple{Any,Type{E},Union{Expr, Symbol},Union{Expr, Symbol}}} where E","page":"Utils","title":"LogicCircuits.Utils.expand_product","text":"generate an expression for the loop-unrolled product of x1 and xs...\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.expand_product-Union{Tuple{E}, Tuple{Any,Type{E},Union{Expr, Symbol}}} where E","page":"Utils","title":"LogicCircuits.Utils.expand_product","text":"generate an expression for the loop-unrolled product of xs...\n\n\n\n\n\n","category":"method"},{"location":"manual/properties/#man-structural-properties-1","page":"Structural Properties","title":"Structural Properties","text":"","category":"section"},{"location":"manual/properties/#","page":"Structural Properties","title":"Structural Properties","text":"note: Note\nThis page is still under construction. For suggestions and fixes, please click on the \"Edit on Github\" button in the top right.","category":"page"},{"location":"manual/properties/#Smoothness-1","page":"Structural Properties","title":"Smoothness","text":"","category":"section"},{"location":"manual/properties/#","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/properties/#Determinism-1","page":"Structural Properties","title":"Determinism","text":"","category":"section"},{"location":"manual/properties/#","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is deterministic if each of its OR nodes are deterministic.  An OR node is deterministic if for every possible assignment to the variables, at most one of the its children can be active (true).","category":"page"},{"location":"manual/properties/#Decomposability-1","page":"Structural Properties","title":"Decomposability","text":"","category":"section"},{"location":"manual/properties/#","page":"Structural Properties","title":"Structural Properties","text":"A logical circuit is decomposable if each of its AND nodes are decomposable.  An AND node is decomposable if for each pair of children the set of variables they depend on is disjoint.","category":"page"},{"location":"manual/properties/#Structured-Decomposability-1","page":"Structural Properties","title":"Structured Decomposability","text":"","category":"section"},{"location":"manual/transformations/#man-tranformations-1","page":"Tranformations","title":"Tranformations","text":"","category":"section"},{"location":"manual/transformations/#Conditioning-1","page":"Tranformations","title":"Conditioning","text":"","category":"section"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, conditioning on the literal x (resp. lnot x) is equivalent to replacing every occurance of X with true (resp. false). ","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"(Delta mid x)","category":"page"},{"location":"manual/transformations/#Forgetting-1","page":"Tranformations","title":"Forgetting","text":"","category":"section"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, forgetting the variable X can be thought of as erasing (forgetting) what the formula says about variable X:","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"exists X Delta ","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Forgeting is also equivalent to disjunction of different ways to condition on X. The possible values for X are the literals x or lnot x, so we have:","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"exists X Delta = (Delta mid x) lor (Delta mid lnot x)","category":"page"},{"location":"manual/transformations/#Smoothing-1","page":"Tranformations","title":"Smoothing","text":"","category":"section"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Smoothing is the act of converting a non-smooth circuit to a circuit representing the same formula that is smooth. A logical circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/transformations/#Apply-1","page":"Tranformations","title":"Apply","text":"","category":"section"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Given two logical circuits Delta_1, Delta_2, and a binary operation o the apply operation outputs a logical circuit representing:","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"    Delta_1 o Delta_2","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"Note that, in addition to representing the correct formula, the apply operation also wants to preserve the structural properites of the circuits such as  determinism and decomposability.","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"The major binary operations are conjunction (land), disjunction (lor), and XOR (oplus). There are 2^4 = 16 possible binary operations, 6 of which are trivial operations (such as always returning false or depending only on one of the circuits). The other 10 can be derived by combination of not operation (lnot) with the main 3 operations mentioned. The list of all possible non-trivial binary operations are below:","category":"page"},{"location":"manual/transformations/#","page":"Tranformations","title":"Tranformations","text":"    Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor lnot Delta_2 \n    Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land lnot Delta_2 \n    Delta_1 oplus Delta_2 lnot (Delta_1 oplus Delta_2) ","category":"page"},{"location":"#LogicCircuits.jl-1","page":"Home","title":"LogicCircuits.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"LogicCircuits.jl module provides a Julia implementation of tools to represent boolean formulas, operate on them, and ask queries about them.    ","category":"page"},{"location":"#What-are-Logic-Circuits?-1","page":"Home","title":"What are Logic Circuits?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Each logical circuit represents a boolean formula.  Internally, they are structured as a DAG with leave nodes being constants (true, false) or literals (X, lnot X).  Internal nodes can be AND or OR nodes.  Note that negation can only be done at the leaves.  This representation of boolean formulas is also known as Negation Normal Form (NNF).  In general, we also want to enforce few other structural properties such as smoothness, determinism, decomposability to enable tractable logical reasoning. ","category":"page"},{"location":"#What-can-we-do-with-them?-1","page":"Home","title":"What can we do with them?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Given a logical circuit there are many questions that we can ask.  For example, we might want to see whether it is satisfiable (SAT),  how many different ways are there to satisfy it (model counting),  or check whether it is equivalent with another logical circuit.  We refer to these as queries.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"On another front, we might want to operate on the logical circuits themselves.  For example, we might want to condition on a literal, forget a variable, conjoin or disjoin two circuits, or negate the circuit.  We refer to these tasks as transformations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In general, many of these tasks are intractable, however given different combinations of  properties on structure of logical circuits we can unlock different queries to become tractable.","category":"page"},{"location":"#Where-to-learn-more-about-them?-1","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Please refer to the Manual section for more details on important concepts, and examples on how to use this module.","category":"page"}]
}
