var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#man-internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"note: Note\nUnder construction.","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"In this section, we give breif overview of important interal design choices for LogicCircuits.jl","category":"page"},{"location":"manual/internals/#Type-System","page":"Internals","title":"Type System","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Explain differences between:","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Sdds\nPlainLogicCircuit\nStructLogicCircuit","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Describe what vtrees are.","category":"page"},{"location":"manual/internals/#Operating-on-Circuits","page":"Internals","title":"Operating on Circuits","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Different ways to traverse circuits:","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Foldup: foldup\nFoldup Aggerage: foldup_aggregate","category":"page"},{"location":"manual/internals/#Flows","page":"Internals","title":"Flows","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Describe each type of flow and their meaning. UpFlow, DownFlow, etc. satisfies_flows, satisfies_flows_down, etc.","category":"page"},{"location":"manual/internals/#GPU-Acceleration","page":"Internals","title":"GPU Acceleration","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"BitCircuits","category":"page"},{"location":"manual/internals/#Misc-Tools","page":"Internals","title":"Misc Tools","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Zoo Artifacts\nTwenty Datsets\nPlotting options plot, or converting to string options tree_formula_string","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"EditURL = \"https://github.com/Juice-jl/LogicCircuits.jl/blob/master/docs/src/usage.jl\"","category":"page"},{"location":"generated/usage/#Quick-Tutorial","page":"Quick Tutorial","title":"Quick Tutorial","text":"","category":"section"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"(Image: Open Notebook)","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Assuming that the LogicCircuits Julia package has been installed with julia -e 'using Pkg; Pkg.add(\"LogicCircuits\")', we can start using it as follows.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"using LogicCircuits","category":"page"},{"location":"generated/usage/#Reasoning-with-manually-constructed-circuits","page":"Quick Tutorial","title":"Reasoning with manually constructed circuits","text":"","category":"section"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"We begin by creating three positive literals (logical variables) and manually constructing a simple circuit using logical connectives & (and), | (or), and - (not).","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"sun, rain, rainbow = pos_literals(LogicCircuit, 3)\ncircuit = (rainbow & sun & rain) | (-rainbow); # rainbow implies sun and rain\nnothing #hide","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Just like any logical circuit or Boolean function, we can evaluate ours on various inputs.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"circuit(false, true, true) # sun is false, rain is true, rainbow is true","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"circuit(true, true, true) # sun is true, rain is true, rainbow is true","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"The purpose of this package, however, is to enable more interesting inference scenarios. This is possible by ensuring that the circuit has certain properties, such as decomposability, determinism, and more. Our current circuit happens to already be decomposable and deterministic by construction:","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"isdecomposable(circuit) && isdeterministic(circuit)","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"The decomposability property ensures that we can ask whether the circuit is satisfiable (the classical SAT problem) and, surprisingly, still get our answer efficiently. Of course, from the input true, true, true tried above, we know the answer to be true.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"issatisfiable(circuit) # does there exist an input that outputs true?","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"In addition, the determinism property allows us to efficiently decide whether the circuit is a tautology (always true), or compute its model count, that is, the number of satisfying assignments.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"istautology(circuit) # do all inputs give the circuit output true?","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"model_count(circuit) # how many possible inputs give the output true?","category":"page"},{"location":"generated/usage/#Reasoning-with-compiled-circuits","page":"Quick Tutorial","title":"Reasoning with compiled circuits","text":"","category":"section"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"As logical sentences become more complicated, it becomes infeasible to manually write down circuits that have the requisite properties that guarantee tractable inference.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"A process called compilation can solve this problem. Concretely, LogicCircuits supports compilation into a particular type of circuit called SDD. We construct an SDD manager with four additional variables, and then ask to compile our running example circuit into an SDD:","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"manager = SddMgr(7, :balanced)\ncircuit = compile(manager, circuit);\nnothing #hide","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Now we are able to incorporate many more logical sentences into the same circuit.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"sun, rain, rainbow, cloud, snow, los_angeles, belgium = pos_literals(Sdd, manager, 7)\ncircuit &= (-los_angeles | -belgium) # cannot be in LA and Belgium at the same time\ncircuit &= (los_angeles ⇒ sun) ∧ (belgium ⇒ cloud) # unicode logical syntax\ncircuit &= (¬(rain ∨ snow) ⇐ ¬cloud); # no rain or snow without clouds\nnothing #hide","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Incorporating these constraints has increased the size of our circuit.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"plot(circuit; simplify=true)","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Crucially, the circuit is still decomposable and deterministic.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"isdecomposable(circuit) && isdeterministic(circuit)","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"This means that we can still decide satisfiability, count models, and solve various inference tasks efficiently. For example, we can compute the fraction of inputs that gives the output true:","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"sat_prob(circuit)","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Moreover, compiled SDD circuits allow for efficiently checking whether one circuit logically entails another circuit, and whether two circuits are logically equivalent.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"entails(circuit, (rainbow ⇒ cloud))","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"entails(circuit, (rainbow ⇒ belgium))","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"equivalent((rainbow ⇒ belgium), (¬belgium ⇒ ¬rainbow))","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"Logical constraints are often written in conjunctive normal form (CNF). These can be loaded from file and compiled into circuits, using an SDD manager whose decomposition structure is specified by a vtree file.","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"manager = SddMgr(zoo_vtree(\"iscas89/s208.1.scan.min.vtree\"))\ncircuit = compile(manager, zoo_cnf(\"iscas89/s208.1.scan.cnf\")) # CNF has 285 clauses\n\"This CNF has $(model_count(circuit)) satisfying assignments. Its circuit has $(num_nodes(circuit)) nodes and $(num_edges(circuit)) edges.\"","category":"page"},{"location":"generated/usage/#Advanced-functionality","page":"Quick Tutorial","title":"Advanced functionality","text":"","category":"section"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"LogicCircuits further provides","category":"page"},{"location":"generated/usage/","page":"Quick Tutorial","title":"Quick Tutorial","text":"CPU (SIMD) and GPU (CUDA) kernels to efficiently compute satisfiability, model counts, etc., for large numbers of inputs, parallelizing over both circuit nodes and data inputs.\nAlgorithms that transform circuits in non-trivial ways (split, clone, smooth, condition, etc.), verify and enforce structural properties.\nFunctionality to load and save circuits in various file formats","category":"page"},{"location":"development/#LogicCircuits.jl-for-Developers","page":"Development","title":"LogicCircuits.jl for Developers","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Follow these instructions to install and use LogicCircuits.jl as a developer of the package.","category":"page"},{"location":"development/#Installation","page":"Development","title":"Installation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Install the Julia package in development mode by running","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"))'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"By default this will install the package at ~/.julia/dev and allow you to change the code there. See the Pkg manual for more details. One can adjust the development directory using environment variables or simply create a symbolic link to/from your favorite development directory.","category":"page"},{"location":"development/#Building-Docs","page":"Development","title":"Building Docs","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"To locally build the docs, first run the following command from root of the repository to instantiate the docs environment and run the build script:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate(); include(\"./docs/make.jl\");'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"The build results will be stored under docs/build.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Alternatively, if you have LogicCircuits in development mode and have already instantiated the docs environment, you can simply run the following:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"development/#Updating-main-README.md","page":"Development","title":"Updating main README.md","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"After running the build script for docs the README.md file gets updated automatically, check the diff and commit the desired changes to README.md.","category":"page"},{"location":"development/#Testing","page":"Development","title":"Testing","text":"","category":"section"},{"location":"development/#Prerequisite","page":"Development","title":"Prerequisite","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Set the following environment variable, to automatically download data artifacts needed during tests without user input. Otherwise the tests would fail or timeout waiting for user input if the artifact is not already downloaded.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"export DATADEPS_ALWAYS_ACCEPT=1","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Additionally, if you want the tests to run faster, you can use more cores by setting the following variable. The default value is 1.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"export JIVE_PROCS=8","category":"page"},{"location":"development/#Running-the-tests:","page":"Development","title":"Running the tests:","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Make sure to run the tests before commiting new code.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"To run all the tests:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=test --color=yes test/runtests.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"You can also run any specific test:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=test --color=yes test/_manual_/aqua_test.jl","category":"page"},{"location":"development/#Releasing-New-Versions","page":"Development","title":"Releasing New Versions","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Only do this for when the repo is in stable position, and we have decent amount of changes from previous version.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Bump up the version in Project.toml\nUse Julia Registrator to submit a pull request to julia's public registry. \nThe web interface seems to be the easiest. Follow the instructions in the generated pull request and make sure there is no errors. For example this pull request.\nGithub Release. TagBot is enabled for this repo, so after the registrator merges the pull request, TagBot automatically does a github release in sync with the registrar's new version. \nNote: TagBot would automatically include all the closed PRs and issues since the previous version in the release note, if you want to exclude some of them, refer to Julia TagBot docs.\nAs much as possible, make sure to also release a new version for ProbabilisticCircuits.jl.","category":"page"},{"location":"development/#Updating-Artifacts","page":"Development","title":"Updating Artifacts","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"The example is for Circuit Model Zoo, but should work for others:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Push new updates to UCLA-StarAI/Circuit-Model-Zoo\nDo a new zoo release.\nUpdate the LogicCircuits.jl's Artifact.toml file with new git tag and hash. Example commit can be found here.\nDo the same for ProbabilisticCircuits.jl's Artifact.toml file. Example commit here.\nNote that for each Artifact.toml, 2 things need to change: git-tree-sha1 and sha256.\nUpdate the const zoo_version = \"/Circuit-Model-Zoo-0.1.4\" inside LogicCircuits.jl to the new zoo version. No changes needed in ProbabilisticCircuits since it uses the same constant.","category":"page"},{"location":"development/#Question:-How-to-get-the-hashes:","page":"Development","title":"Question: How to get the hashes:","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"Download the new Zoo release from Github. Now you can use the following code snippet to get the hashes (check the julia Artifact page for latest instructions):","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"using Tar, Inflate, SHA\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Prerequisites","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia 1.5 or greater. For installation, please refer to the official Julia Website.","category":"page"},{"location":"installation/#Installing-LogicCircuits","page":"Installation","title":"Installing LogicCircuits","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can use Julia's package manager, Pkg, to install this module and its dependencies. There are different options on how to do that, for example through command line or julia REPL. For more information and options on how to use Julia pacakge manager, please refer to Pkg's Documentation.","category":"page"},{"location":"installation/#From-Command-Line","page":"Installation","title":"From Command Line","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest stable release, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(\"LogicCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the package with the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia -e 'using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/Juice-jl/LogicCircuits.jl.git\"))'","category":"page"},{"location":"installation/#From-Julia-Pkg-REPL","page":"Installation","title":"From Julia Pkg REPL","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nTo get to Pkg mode, you need to run julia, then to press ]. Press backspace or ^C to get back to normal REPL mode.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"While in Pkg mode, run the following to install the latest release:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Similarly, to install from the latest commits on master branch, run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add LogicCircuits#master","category":"page"},{"location":"installation/#Testing","page":"Installation","title":"Testing","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are installing the latest commit, we recommend running the test suite to make sure everything is in order, to do that run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia --color=yes -e 'using Pkg; Pkg.test(\"LogicCircuits\")'","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want the tests to run faster, you can use multiple cores. To do that set the following environment variable (default = 1 core):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"export JIVE_PROCS=8","category":"page"},{"location":"manual/compilation/#man-compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"manual/compilation/","page":"Compilation","title":"Compilation","text":"note: Note\nUnder Construction. ","category":"page"},{"location":"manual/compilation/#What-is-compliation?","page":"Compilation","title":"What is compliation?","text":"","category":"section"},{"location":"manual/compilation/#Why-is-it-needed?","page":"Compilation","title":"Why is it needed?","text":"","category":"section"},{"location":"manual/compilation/#Supported-compliations-routines","page":"Compilation","title":"Supported compliations routines","text":"","category":"section"},{"location":"manual/compilation/","page":"Compilation","title":"Compilation","text":"From UAI \nFrom CNF/DNF\nConverting between Sdd, StructLogicCircuit, PlainLogicCircuit","category":"page"},{"location":"api/public/#api-public","page":"Public APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"This page lists documentation for the most commonly used public APIs of LogicCircuits.jl. Visit the internals section for a auto generated documentation for more public API and internal APIs.","category":"page"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Circuit-Properties","page":"Public APIs","title":"Circuit Properties","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"issmooth\nisdecomposable\nisdeterministic\niscanonical","category":"page"},{"location":"api/public/#LogicCircuits.issmooth","page":"Public APIs","title":"LogicCircuits.issmooth","text":"issmooth(root::LogicCircuit)::Bool\n\nIs the circuit smooth?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.isdecomposable","page":"Public APIs","title":"LogicCircuits.isdecomposable","text":"isdecomposable(root::LogicCircuit)::Bool\n\nIs the circuit decomposable?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.isdeterministic","page":"Public APIs","title":"LogicCircuits.isdeterministic","text":"isdeterministic(root::LogicCircuit)::Bool\n\nIs the circuit determinstic? Note: this function is generally intractable for large circuits.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.iscanonical","page":"Public APIs","title":"LogicCircuits.iscanonical","text":"iscanonical(circuit::LogicCircuit, k::Int; verbose = false)\n\nDoes the given circuit have canonical Or gates, as determined by a probabilistic equivalence check?\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Queries","page":"Public APIs","title":"Circuit Queries","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"sat_prob\nmodel_count","category":"page"},{"location":"api/public/#LogicCircuits.sat_prob","page":"Public APIs","title":"LogicCircuits.sat_prob","text":"sat_prob(root::LogicCircuit; varprob::Function)::Rational{BigInt}\n\nGet the probability that a random world satisties the circuit.  Probability of each variable is given by varprob Function which defauls to 1/2 for every variable.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.model_count","page":"Public APIs","title":"LogicCircuits.model_count","text":"model_count(root::LogicCircuit, num_vars_in_scope::Int = num_variables(root))::BigInt\n\nGet the model count of the circuit.  The num_vars_in_scope is set to number of variables in the circuit, but sometimes need to set different values,  for example, if not every variable is mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Operations","page":"Public APIs","title":"Circuit Operations","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"foldup\nfoldup_aggregate","category":"page"},{"location":"api/public/#LogicCircuits.Utils.foldup","page":"Public APIs","title":"LogicCircuits.Utils.foldup","text":"foldup(node::Dag, \n    f_leaf::Function, \n    f_inner::Function, \n    ::Type{T})::T where {T}\n\nCompute a function bottom-up on the graph.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\nfoldup(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.Utils.foldup_aggregate","page":"Public APIs","title":"LogicCircuits.Utils.foldup_aggregate","text":"Compute a function bottom-up on the circuit.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner in aggregate  as a vector from the children.\n\n\n\n\n\nfoldup_aggregate(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T})::T where T\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Circuit-Transformations","page":"Public APIs","title":"Circuit Transformations","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"smooth\nconjoin\nforget\ndeepcopy\nsplit\nclone\npropagate_constants","category":"page"},{"location":"api/public/#LogicCircuits.smooth","page":"Public APIs","title":"LogicCircuits.smooth","text":"smooth(root::StructLogicCircuit)::StructLogicCircuit\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\nsmooth(root::Node)::Node\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\nSmooth an sdd to a StructLogicCircuit\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.forget","page":"Public APIs","title":"LogicCircuits.forget","text":"forget(root::Node, is_forgotten::Function)::Node\n\nForget variables from the circuit. Warning: this may or may not destroy the determinism property.\n\n\n\n\n\nReturns the resulting BDD after applying the forget operation. Equivalent to phi_x vee phi_neg x.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Base.deepcopy","page":"Public APIs","title":"Base.deepcopy","text":"deepcopy(n::Node, depth::Int64)\n\nRecursively create a copy circuit rooted at n to a certain depth depth\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Base.split","page":"Public APIs","title":"Base.split","text":"split(root::Node, (or, and)::Tuple{Node, Node}, var::Var; depth=0, sanity_check=true)\n\nReturn the circuit after spliting on edge edge and variable var\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.clone","page":"Public APIs","title":"LogicCircuits.clone","text":"Clone the or node and redirect one of its parents to the new copy\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.propagate_constants","page":"Public APIs","title":"LogicCircuits.propagate_constants","text":"propagate_constants(root::Node)\n\nRemove all constant leafs from the circuit\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Compilation","page":"Public APIs","title":"Compilation","text":"","category":"section"},{"location":"api/public/#GPU-Related","page":"Public APIs","title":"GPU Related","text":"","category":"section"},{"location":"api/public/","page":"Public APIs","title":"Public APIs","text":"isgpu\nto_gpu\nto_cpu","category":"page"},{"location":"api/public/#LogicCircuits.Utils.isgpu","page":"Public APIs","title":"LogicCircuits.Utils.isgpu","text":"Check whether data resides on the GPU\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.Utils.to_gpu","page":"Public APIs","title":"LogicCircuits.Utils.to_gpu","text":"Move data to the GPU\n\n\n\n\n\n","category":"function"},{"location":"api/public/#LogicCircuits.Utils.to_cpu","page":"Public APIs","title":"LogicCircuits.Utils.to_cpu","text":"Move data to the CPU\n\n\n\n\n\n","category":"function"},{"location":"api/types/#api-types","page":"Type Trees","title":"Type Trees","text":"","category":"section"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"The following code snippet provides an easy way to print the type tree of logic circuits.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"using InteractiveUtils;\nusing LogicCircuits;\nusing AbstractTrees;\nAbstractTrees.children(x::Type) = subtypes(x);","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"For example, we can see LogicCircuits.LogicCircuit's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(LogicCircuit)","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"Alternatively, here's Vtree's type tree.","category":"page"},{"location":"api/types/","page":"Type Trees","title":"Type Trees","text":"AbstractTrees.print_tree(Vtree)","category":"page"},{"location":"manual/queries/#man-queries","page":"Queries","title":"Queries","text":"","category":"section"},{"location":"manual/queries/#Evaluation","page":"Queries","title":"Evaluation","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta and an assignment to its variable, we would like to know the output of the circuit. For example, if Delta = X land Y, and we assign x, lnot y:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"X land Y = texttrue land textfalse = textfalse","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\");\nX = rand(Bool, num_variables(lc));\n\nlc(X)","category":"page"},{"location":"manual/queries/#Satisfiability","page":"Queries","title":"Satisfiability","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta, the goal of SAT is to answer whether there is an assignment to its variables such that the output is true. Depending on the structural properties of the logic circuit this problem can be intractable or tractable.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"We can use sat_prob to compute probability of a random world satisfying the circuit. Note that sat_prob assumes that we have a smooth, deterministic, and decomposable circuit.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\");\nprob = sat_prob(lc);\nFloat64(prob)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"By default, every postive literal x_i has probability 1/2, we can set probability of literal values to any constant probabilities, for example:","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"prob = sat_prob(lc; varprob = (i) -> BigInt(1) // BigInt(3));\nFloat64(prob)","category":"page"},{"location":"manual/queries/#Model-Counting","page":"Queries","title":"Model Counting","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given a logic circuit Delta, the goal of model counting is to count how many ways there are to assign values to variables of Delta such that the output of the circuit is true. Note that model_count assumes we have a smooth, deterministic, and decomposable circuit.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"using LogicCircuits # hide\nlc = smooth(zoo_sdd(\"random.sdd\"));\nmodel_count(lc)","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Let's see how conjoining affects the model count. Observe that model count of Delta should equal to adding model counts of Delta mid x_2 and Delta mid lnot x_2.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"c2 = conjoin(lc, Lit(2));\nc2not = conjoin(lc, Lit(-2));\nmodel_count(c2, num_variables(lc)), model_count(c2not, num_variables(lc))","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Note that some transformations lead to losing required properties needed for tractable model count. For example, after forgetting variables we lose determinism and hence cannot use model_count anymore.","category":"page"},{"location":"manual/queries/#Equivalence-Checking","page":"Queries","title":"Equivalence Checking","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Given two logic circuits Delta_1 and Delta_2, the goal is to check whether these two circuits represent the same formula. There are both determnistic and probabilistic algorithms for this task.","category":"page"},{"location":"manual/queries/#Misc","page":"Queries","title":"Misc","text":"","category":"section"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"Here are few other useful queries. Look inside thier documentation for more details.","category":"page"},{"location":"manual/queries/","page":"Queries","title":"Queries","text":"variables: Get the variable mentioned in the circuit root.\ninfer_vtree Infer vtree of struct decomposable circuits.\nimplied_literals Implied Literals.","category":"page"},{"location":"api/internals/logiccircuits/#api-internal-logic-circuits","page":"LogicCircuits","title":"LogicCircuits","text":"","category":"section"},{"location":"api/internals/logiccircuits/","page":"LogicCircuits","title":"LogicCircuits","text":"Modules = [LogicCircuits]","category":"page"},{"location":"api/internals/logiccircuits/#LogicCircuits.false_sdd","page":"LogicCircuits","title":"LogicCircuits.false_sdd","text":"Canonical false Sdd node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.structfalse","page":"LogicCircuits","title":"LogicCircuits.structfalse","text":"The unique splain tructured logical false constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.structtrue","page":"LogicCircuits","title":"LogicCircuits.structtrue","text":"The unique plain structured logical true constant\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.true_sdd","page":"LogicCircuits","title":"LogicCircuits.true_sdd","text":"Canonical true Sdd node\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/logiccircuits/#LogicCircuits.ApplyArgs","page":"LogicCircuits","title":"LogicCircuits.ApplyArgs","text":"Representation of the arguments of an Apply call\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.ApplyCache","page":"LogicCircuits","title":"LogicCircuits.ApplyCache","text":"Apply cache for the result of conjunctions and disjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Bdd","page":"LogicCircuits","title":"LogicCircuits.Bdd","text":"A Binary Decision Diagram.\n\nindex: the vertex variable (-1 if terminal vertex\nlow: low child vertex of BDD (undef if terminal vertex)\nhigh: high child vertex of BDD (undef if terminal vertex)\nvalue: terminal boolean value\nid: unique identifier\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.BitCircuit","page":"LogicCircuits","title":"LogicCircuits.BitCircuit","text":"A bit circuit is a low-level representation of a logical circuit structure.\n\nThey are a \"flat\" representation of a circuit, essentially a bit string, that can be processed by lower level code (e.g., GPU kernels)\n\nThe wiring of the circuit is captured by two matrices: nodes and elements.\n\nNodes are either leafs or decision (disjunction) nodes in the circuit.\nElements are conjunction nodes in the circuit.\nIn addition, there is a vector of layers, where each layer is a list of node ids. Layer 1 is the leaf/input layer. Layer end is the circuit root.\nAnd there is a vector of parents, pointing to element id parents of decision nodes.\n\nNodes are represented as a 4xN matrix where\n\nnodes[1,:] is the first element id belonging to this decision\nnodes[2,:] is the last element id belonging to this decision\nnodes[3,:] is the first parent index belonging to this decision\nnodes[4,:] is the last parent index belonging to this decision\n\nElements belonging to node i are elements[:, nodes[1,i]:nodes[2,i]]   Parents belonging to node i are parents[nodes[3,i]:nodes[4,i]]\n\nElements are represented by a 3xE matrix, where \n\nelements[1,:] is the decision node id (parents of the element),\nelements[2,:] is the prime node id (child of the element) \nelements[3,:] is the sub node id (child of the element)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.BitCircuit-Tuple{LogicCircuit, Int64}","page":"LogicCircuits","title":"LogicCircuits.BitCircuit","text":"construct a new BitCircuit accomodating the given number of features\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.ConstantGate","page":"LogicCircuits","title":"LogicCircuits.ConstantGate","text":"A trait denoting constant leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Element","page":"LogicCircuits","title":"LogicCircuits.Element","text":"Represents elements that are not yet compiled into conjunctions\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType","page":"LogicCircuits","title":"LogicCircuits.GateType","text":"A trait hierarchy denoting types of nodes GateType defines an orthogonal type hierarchy of node types, not circuit types, so we can dispatch on node type regardless of circuit type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.GateType-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.GateType","text":"Get the gate type trait of the given LogicCircuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.InnerGate","page":"LogicCircuits","title":"LogicCircuits.InnerGate","text":"A logical gate that is an inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LeafGate","page":"LogicCircuits","title":"LogicCircuits.LeafGate","text":"A logical gate that is a leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LiteralGate","page":"LogicCircuits","title":"LogicCircuits.LiteralGate","text":"A trait denoting literal leaf nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.LogicCircuit","page":"LogicCircuits","title":"LogicCircuits.LogicCircuit","text":"Root of the logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.NodeId","page":"LogicCircuits","title":"LogicCircuits.NodeId","text":"Integer identifier for a circuit node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.NodeIds","page":"LogicCircuits","title":"LogicCircuits.NodeIds","text":"The BitCircuit ids associated with a node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainConstantNode","page":"LogicCircuits","title":"LogicCircuits.PlainConstantNode","text":"A plain logical constant leaf node, representing true or false\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLiteralNode","page":"LogicCircuits","title":"LogicCircuits.PlainLiteralNode","text":"A plain logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.PlainLogicCircuit","text":"Root of the plain logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicInnerNode","page":"LogicCircuits","title":"LogicCircuits.PlainLogicInnerNode","text":"A plain logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainLogicLeafNode","page":"LogicCircuits","title":"LogicCircuits.PlainLogicLeafNode","text":"A plain logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructConstantNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructConstantNode","text":"A plain structured logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLiteralNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLiteralNode","text":"A plain structured logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicCircuit","text":"Root of the plain structure logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicInnerNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicInnerNode","text":"A plain structured logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStructLogicLeafNode","page":"LogicCircuits","title":"LogicCircuits.PlainStructLogicLeafNode","text":"A plain structured logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋀Node","page":"LogicCircuits","title":"LogicCircuits.PlainStruct⋀Node","text":"A plain structured logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainStruct⋁Node","page":"LogicCircuits","title":"LogicCircuits.PlainStruct⋁Node","text":"A plain structured logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.PlainVtree","page":"LogicCircuits","title":"LogicCircuits.PlainVtree","text":"Root of the plain vtree node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋀Node","page":"LogicCircuits","title":"LogicCircuits.Plain⋀Node","text":"A plain logical conjunction node (And node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Plain⋁Node","page":"LogicCircuits","title":"LogicCircuits.Plain⋁Node","text":"A plain logical disjunction node (Or node)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd","page":"LogicCircuits","title":"LogicCircuits.Sdd","text":"Root of the trimmed Sdd circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddConstantNode","page":"LogicCircuits","title":"LogicCircuits.SddConstantNode","text":"A SDD logical constant leaf node, representing true or false. These are the only structured nodes that don't have an associated vtree node (cf. SDD file format)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddInnerNode","page":"LogicCircuits","title":"LogicCircuits.SddInnerNode","text":"A SDD logical inner node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLeafNode","page":"LogicCircuits","title":"LogicCircuits.SddLeafNode","text":"A SDD logical leaf node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddLiteralNode","page":"LogicCircuits","title":"LogicCircuits.SddLiteralNode","text":"A SDD logical literal leaf node, representing the positive or negative literal of its variable\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgr","page":"LogicCircuits","title":"LogicCircuits.SddMgr","text":"Root of the SDD manager node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgrInnerNode","page":"LogicCircuits","title":"LogicCircuits.SddMgrInnerNode","text":"SDD manager inner vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.SddMgrLeafNode","page":"LogicCircuits","title":"LogicCircuits.SddMgrLeafNode","text":"SDD manager leaf vtree node for trimmed SDD nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋀Node","page":"LogicCircuits","title":"LogicCircuits.Sdd⋀Node","text":"A SDD logical conjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Sdd⋁Node","page":"LogicCircuits","title":"LogicCircuits.Sdd⋁Node","text":"A SDD logical disjunction node\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.StructLogicCircuit","page":"LogicCircuits","title":"LogicCircuits.StructLogicCircuit","text":"Root of the structure logic circuit node hierarchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Unique⋁Cache","page":"LogicCircuits","title":"LogicCircuits.Unique⋁Cache","text":"Unique nodes cache for decision nodes\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.Vtree","page":"LogicCircuits","title":"LogicCircuits.Vtree","text":"Root of the vtree node hiearchy\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.XYPartition","page":"LogicCircuits","title":"LogicCircuits.XYPartition","text":"Represent an XY-partition that has not yet been compiled into a disjunction\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀Gate","page":"LogicCircuits","title":"LogicCircuits.⋀Gate","text":"A trait denoting conjuction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁Gate","page":"LogicCircuits","title":"LogicCircuits.⋁Gate","text":"A trait denoting disjunction nodes of any type\n\n\n\n\n\n","category":"type"},{"location":"api/internals/logiccircuits/#Base.:!=-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"Base.:!=","text":"Returns whether the two given boolean functions are not equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.:==-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"Base.:==","text":"Returns whether the two given boolean functions are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.:|-Union{Tuple{T}, Tuple{Bdd, Dict{T, Bool}}} where T<:Integer","page":"LogicCircuits","title":"Base.:|","text":"Returns a new reduced Bdd restricted to instantiation X.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.:⊻-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"Base.:⊻","text":"Returns a xor of the given boolean functions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.deepcopy","page":"LogicCircuits","title":"Base.deepcopy","text":"deepcopy(n::Node, depth::Int64)\n\nRecursively create a copy circuit rooted at n to a certain depth depth\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#Base.hash-Tuple{Bdd, UInt64}","page":"LogicCircuits","title":"Base.hash","text":"Returns a unique hash for the whole BDD.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.merge-Tuple{Node, Node, Node}","page":"LogicCircuits","title":"Base.merge","text":"merge(root::Node, or1::Node, or2::Node)\n\nMerge two circuits.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.sign-Tuple{Bdd}","page":"LogicCircuits","title":"Base.sign","text":"Returns 0 if x is not a literal; else returns the literal's sign.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.size-Tuple{Bdd}","page":"LogicCircuits","title":"Base.size","text":"Returns the number of nodes in the BDD graph.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.split-Tuple{Node, Tuple{Node, Node}, UInt32}","page":"LogicCircuits","title":"Base.split","text":"split(root::Node, (or, and)::Tuple{Node, Node}, var::Var; depth=0, sanity_check=true)\n\nReturn the circuit after spliting on edge edge and variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.string-Tuple{Bdd}","page":"LogicCircuits","title":"Base.string","text":"Return string representation of Bdd α.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.write-Tuple{AbstractString, Vtree}","page":"LogicCircuits","title":"Base.write","text":"write(file::AbstractString, vtree::PlainVtree)\n\nSaves a vtree in the given file path based on file format. Supported formats:\n\n\".vtree\" for Vtree files\n\".dot\" for dot files\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#Base.xor-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"Base.xor","text":"Exclusive logical disjunction (XOR)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:¬-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.:¬","text":"Negates this boolean function.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:¬-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.:¬","text":"Logical negation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:⇐-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.:⇐","text":"Material logical implication (reverse)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:⇒-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.:⇒","text":"Material logical implication\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:⇔-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.:⇔","text":"Bidirectional logical implication\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:∧-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"LogicCircuits.:∧","text":"Returns a conjunction over the given boolean functions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:∧-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.:∧","text":"Logical conjunction\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:∨-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"LogicCircuits.:∨","text":"Returns a disjunction over the given boolean functions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.:∨-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.:∨","text":"Logical disjunction\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.children-Tuple{PlainLogicInnerNode}","page":"LogicCircuits","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.depth-Tuple{Vtree, UInt32}","page":"LogicCircuits","title":"LogicCircuits.Utils.depth","text":"Compute the path length from vtree node n to leaf node for variable var\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.find_inode-Tuple{Any, Any}","page":"LogicCircuits","title":"LogicCircuits.Utils.find_inode","text":"Find an inner vtree node that has left in its left subtree and right in its right subtree. Supports nothing as a catch-all for any node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.find_leaf-Tuple{UInt32, Vtree}","page":"LogicCircuits","title":"LogicCircuits.Utils.find_leaf","text":"Find the leaf in the vtree that represents the given variable\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{LogicCircuit, Function, Function, Function, Function, Type{T}}, Tuple{LogicCircuit, Function, Function, Function, Function, Type{T}, Any}} where T","page":"LogicCircuits","title":"LogicCircuits.Utils.foldup","text":"foldup(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function)::T where {T}\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o through a callback from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{LogicCircuit, Function, Function, Function, Function, Type{T}}, Tuple{LogicCircuit, Function, Function, Function, Function, Type{T}, Any}} where T","page":"LogicCircuits","title":"LogicCircuits.Utils.foldup_aggregate","text":"foldup_aggregate(node::LogicCircuit, \n    f_con::Function, \n    f_lit::Function, \n    f_a::Function, \n    f_o::Function, \n    ::Type{T})::T where T\n\nCompute a function bottom-up on the circuit.  f_con is called on constant gates, f_lit is called on literal gates,  f_a is called on conjunctions, and f_o is called on disjunctions. Values of type T are passed up the circuit and given to f_a and f_o in an aggregate vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.lca-Tuple{Union{Nothing, Vtree}, Union{Nothing, Vtree}}","page":"LogicCircuits","title":"LogicCircuits.Utils.lca","text":"Compute the lowest common ancestor of two vtree nodes Warning: this method uses an incomplete varsubset check for descends_from and is only correct when v and w are part of the same larger vtree.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.num_nodes-Tuple{BitCircuit}","page":"LogicCircuits","title":"LogicCircuits.Utils.num_nodes","text":"How many nodes are indexed by a given bit circuit?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.Utils.variables","page":"LogicCircuits","title":"LogicCircuits.Utils.variables","text":"variables(root::LogicCircuit)::BitSet\n\nGet a bitset of variables mentioned in the circuit root.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.all_valuations-Union{Tuple{Union{Set{T}, UnitRange{T}, AbstractVector{T}}}, Tuple{T}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.all_valuations","text":"Computes all possible valuations of scope V and returns as a BitMatrix. Up to 64 variables.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.and-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"LogicCircuits.and","text":"Returns a conjunction over the given boolean functions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.and_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.and_nodes","text":"Get the list of And nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.apply-Tuple{Bdd, Bdd, Any}","page":"LogicCircuits","title":"LogicCircuits.apply","text":"Returns a Bdd canonical representation of α ⊕ β, where ⊕ is some binary operator.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.apply_step-Tuple{Bdd, Bdd, Any, Dict{Tuple{Int64, Int64}, Bdd}}","page":"LogicCircuits","title":"LogicCircuits.apply_step","text":"Recursively computes α ⊕ β. If the result was already computed as an intermediate result, return the cached result in T.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.atleast!-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.atleast!","text":"Constructs a BDD mapping to true if at least n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.atleast-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.atleast","text":"Constructs a BDD mapping to true if at least n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.atmost!-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.atmost!","text":"Constructs a BDD mapping to true if at most n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.atmost-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.atmost","text":"Constructs a BDD mapping to true if at most n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.balance_threads-Tuple{Any, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.balance_threads","text":"assign threads to examples and decision nodes so that everything is a power of 2\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.bdd_var-Tuple{Integer}","page":"LogicCircuits","title":"LogicCircuits.bdd_var","text":"Returns a Bdd representing a single variable. If negative, negate variable.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_constants-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.canonical_constants","text":"Construct a mapping from constants to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonical_literals-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.canonical_literals","text":"Construct a mapping from literals to their canonical node representation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize-Tuple{Vector{LogicCircuits.Element}, LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.canonicalize","text":"Get the canonical compilation of the given XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.canonicalize_compressed-Tuple{Vector{LogicCircuits.Element}, LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.canonicalize_compressed","text":"Get the canonical compilation of the given compressed XY Partition\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.clone-NTuple{4, Node}","page":"LogicCircuits","title":"LogicCircuits.clone","text":"Clone the or node and redirect one of its parents to the new copy\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compile","page":"LogicCircuits","title":"LogicCircuits.compile","text":"Create new circuit nodes in the given context.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.compile-Tuple{LogicCircuits.SddMgrLeafNode, Int32}","page":"LogicCircuits","title":"LogicCircuits.compile","text":"Compile a given variable, literal, or constant\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.compress-Tuple{Vector{LogicCircuits.Element}}","page":"LogicCircuits","title":"LogicCircuits.compress","text":"Compress a given XY Partition (merge elements with identical subs)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin","page":"LogicCircuits","title":"LogicCircuits.conjoin","text":"Conjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin-Tuple{Node, Int32}","page":"LogicCircuits","title":"LogicCircuits.conjoin","text":"conjoin(root::Node, lit::Lit; callback::Function)::Node\n\nReturn the circuit conjoined with th given literal constrains callback is called after modifying conjunction node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin-Tuple{SddConstantNode, SddConstantNode}","page":"LogicCircuits","title":"LogicCircuits.conjoin","text":"Conjoin two SDDs\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_cartesian-Tuple{Sdd⋁Node, Sdd⋁Node}","page":"LogicCircuits","title":"LogicCircuits.conjoin_cartesian","text":"Conjoin two SDDs when they respect the same vtree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_descendent-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.conjoin_descendent","text":"Conjoin two SDDs when one descends from the other\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjoin_indep-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.conjoin_indep","text":"Conjoin two SDDs in separate parts of the vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.conjunctions-Union{Tuple{Union{Set{T}, UnitRange{T}, AbstractVector{T}}}, Tuple{T}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.conjunctions","text":"Computes all possible valuations of scope V as conjunctions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.constant-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.constant","text":"Get the logical constant in a given constant leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.construct_new_sdd_literal-Tuple{LogicCircuits.SddMgrLeafNode, Int32}","page":"LogicCircuits","title":"LogicCircuits.construct_new_sdd_literal","text":"Helper function to construct new SDD literal objects in SddMgrLeafNode constructor\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.convals-Union{Tuple{Union{Set{T}, UnitRange{T}, AbstractVector{T}}}, Tuple{T}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.convals","text":"Computes all possible valuations of scope V as both conjunctions and instantiation values.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.culledfreqs-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.culledfreqs","text":"Returns an approximation (does not account for some repeated nodes) of how many times each variable is mentioned in α.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.disjoin","page":"LogicCircuits","title":"LogicCircuits.disjoin","text":"Disjoin nodes into a single circuit\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.eliminate-Tuple{Bdd, Integer}","page":"LogicCircuits","title":"LogicCircuits.eliminate","text":"Eliminate a variable through disjunction. Equivalent to the expression (ϕ|x ∨ ϕ|¬x).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.entails-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.entails","text":"Decide whether one sentence logically entails another\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.equivalent-Tuple{Sdd, Sdd}","page":"LogicCircuits","title":"LogicCircuits.equivalent","text":"Decide whether two sentences are logically equivalent\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.exactly!-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.exactly!","text":"Constructs a BDD mapping to true if exactly n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.exactly-Union{Tuple{T}, Tuple{Integer, Vector{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.exactly","text":"Constructs a BDD mapping to true if exactly n literals in L are in the input; otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.fill_missing_vtree-Tuple{StructLogicCircuit, Any, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.fill_missing_vtree","text":"Construct a smoothed node from startvtr, when you get to endvtr insert the original node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.forget-Tuple{Bdd, Integer}","page":"LogicCircuits","title":"LogicCircuits.forget","text":"Returns the resulting BDD after applying the forget operation. Equivalent to phi_x vee phi_neg x.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.forget-Tuple{Node, Function}","page":"LogicCircuits","title":"LogicCircuits.forget","text":"forget(root::Node, is_forgotten::Function)::Node\n\nForget variables from the circuit. Warning: this may or may not destroy the determinism property.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.from_npbc-Union{Tuple{T}, Tuple{Vector{T}, Integer}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.from_npbc","text":"Translates a cardinality constraint in normal pseudo-boolean constraint form into a BDD.\n\nSince cardinality constraints correspond to having coefficients set to one, we ignore the C's.\n\nArgument L corresponds to the vector of literals to be chosen from; b is how many literals in L are selected.\n\nSee Eén and Sörensson 2006.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.fully_factorized_circuit","page":"LogicCircuits","title":"LogicCircuits.fully_factorized_circuit","text":"Generate a fully factorized circuit over the given range of variables\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.global_scope-Tuple{Vtree}","page":"LogicCircuits","title":"LogicCircuits.global_scope","text":"Get the variable scope of the root of this vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.has_single_child-Tuple{Any, Any}","page":"LogicCircuits","title":"LogicCircuits.has_single_child","text":"Does the bitcircuit node have a single child?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.implied_literals","page":"LogicCircuits","title":"LogicCircuits.implied_literals","text":"implied_literals(root::LogicCircuit)::Union{BitSet, Nothing}\n\nCompute at each node literals that are implied by the formula.  nothing at a node means all literals are implied (i.e. the node's formula is false)\n\nThis algorithm is sound but not complete - all literals returned are correct, but some true implied literals may be missing. \n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.infer_vtree","page":"LogicCircuits","title":"LogicCircuits.infer_vtree","text":"infer_vtree(root::LogicCircuit)::Vtree\n\nInfer circuits vtree if the circuit is struct-decomposable it. Otherwise return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.init_satisfies-Tuple{Any, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.init_satisfies","text":"Initialize values from the data (data frames)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_atom-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_atom","text":"Returns whether the given Bdd node is an atomic formula (i.e. a variable, ⊥, ⊤, or literal).\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_lit-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_lit","text":"Returns whether the given Bdd node represents a literal.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_term-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_term","text":"Returns whether this Bdd node is terminal.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_var-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_var","text":"Returns whether the given Bdd node represents a variable.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_⊤-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_⊤","text":"Returns whether the given Bdd node represents a ⊤.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is_⊥-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.is_⊥","text":"Returns whether the given Bdd node represents a ⊥.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.iscanonical-Tuple{LogicCircuit, Int64}","page":"LogicCircuits","title":"LogicCircuits.iscanonical","text":"iscanonical(circuit::LogicCircuit, k::Int; verbose = false)\n\nDoes the given circuit have canonical Or gates, as determined by a probabilistic equivalence check?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.iscnf-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.iscnf","text":"Is the circuit a conjunction of disjunctive clauses?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isconstantgate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isconstantgate","text":"Is the node a constant gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdecomposable","page":"LogicCircuits","title":"LogicCircuits.isdecomposable","text":"isdecomposable(root::LogicCircuit)::Bool\n\nIs the circuit decomposable?\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdeterministic","page":"LogicCircuits","title":"LogicCircuits.isdeterministic","text":"isdeterministic(root::LogicCircuit)::Bool\n\nIs the circuit determinstic? Note: this function is generally intractable for large circuits.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.isdnf-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isdnf","text":"Is the circuit a disjunction of conjunctive clauses?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isfalse-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.isfalse","text":"Is the circuit syntactically equal to false?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isflat-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isflat","text":"Is the circuit a flat DNF or CNF structure?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isinnergate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isinnergate","text":"Is the node an inner gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isleafgate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isleafgate","text":"Is the node a leaf gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.isliteralgate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.isliteralgate","text":"Is the node a literal gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.ispositive-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.ispositive","text":"Get the sign of the literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.issatisfiable-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.issatisfiable","text":"issatisfiable(root::LogicCircuit)::Bool\n\nDetermine whether the logical circuit is satisfiable (has a satisfying assignment). Requires decomposability of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.issmooth","page":"LogicCircuits","title":"LogicCircuits.issmooth","text":"issmooth(root::LogicCircuit)::Bool\n\nIs the circuit smooth?\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.isstruct_decomposable-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.isstruct_decomposable","text":"isstruct_decomposable(root::LogicCircuit)::Bool\n\nIs the circuit structured-decomposable?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.istautology-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.istautology","text":"istautology(root::LogicCircuit)::Bool    \n\nDetermine whether the logical circuit is a tautology (every assignment satisfies it; the sentence is valid).  Requires decomposability and determinism of the circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.istrue-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.istrue","text":"Is the circuit syntactically equal to true?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋀gate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.is⋀gate","text":"Is the node an And gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.is⋁gate-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.is⋁gate","text":"Is the node an Or gate?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.lit_val-Tuple{Bdd, Integer}","page":"LogicCircuits","title":"LogicCircuits.lit_val","text":"Returns whether a variable x appears as a positive literal in α, given that α is a conjunction of literals.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.lit_vec-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.lit_vec","text":"Assumes ϕ is a full conjunction of literals. Returns ϕ as a zero-one vector and its scope.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literal-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.literal","text":"Get the logical literal in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literal_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.literal_nodes","text":"Get the list of literal nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.literals-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:LogicCircuit","page":"LogicCircuits","title":"LogicCircuits.literals","text":"Get a sequence of positive and negative literals\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.load-Tuple{Type{Bdd}, String}","page":"LogicCircuits","title":"LogicCircuits.load","text":"Loads a BDD from given file.\n\nSupported file formats:\n\nCNF (.cnf);\nDNF (.dnf);\nBDD (.bdd).\n\nTo load as any of these file formats, simply set the filename with the desired extension.\n\nKeyword arguments are passed down to the open function.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.load_bdd-Tuple{Type{Bdd}, String}","page":"LogicCircuits","title":"LogicCircuits.load_bdd","text":"Loads a BDD from a file. Use load instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.load_cnf-Tuple{Type{Bdd}, String}","page":"LogicCircuits","title":"LogicCircuits.load_cnf","text":"Loads a CNF as a BDD. Use load instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.load_dnf-Tuple{Type{Bdd}, String}","page":"LogicCircuits","title":"LogicCircuits.load_dnf","text":"Loads a CNF as a BDD. Use load instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.map_parents-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.map_parents","text":"Computes a mapping of the parents of each node.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.marginalize-Tuple{Bdd, Integer, Any}","page":"LogicCircuits","title":"LogicCircuits.marginalize","text":"Marginalize a variable through some binary operation.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.max_variable","page":"LogicCircuits","title":"LogicCircuits.max_variable","text":"Get the variable in the circuit with the largest index\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.mentions-Tuple{Bdd, Integer}","page":"LogicCircuits","title":"LogicCircuits.mentions","text":"Returns whether the formula (i.e. BDD) mentions a variable.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.mgr-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.mgr","text":"Get the manager of a Sdd node, which is its SddMgr vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.model_count","page":"LogicCircuits","title":"LogicCircuits.model_count","text":"model_count(root::LogicCircuit, num_vars_in_scope::Int = num_variables(root))::BigInt\n\nGet the model count of the circuit.  The num_vars_in_scope is set to number of variables in the circuit, but sometimes need to set different values,  for example, if not every variable is mentioned in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.model_var_prob-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.model_var_prob","text":"Compute the probability of each variable for a random satisfying assignment of the logical circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.neg_literals-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:LogicCircuit","page":"LogicCircuits","title":"LogicCircuits.neg_literals","text":"Get a sequence of negative literals\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.negate-Tuple{SddConstantNode}","page":"LogicCircuits","title":"LogicCircuits.negate","text":"Negate an SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.normal_form-Tuple{Bdd, Bool}","page":"LogicCircuits","title":"LogicCircuits.normal_form","text":"Runs a BFS on the mapping of parents, starting from either a ⊤ (true) or ⊥ (false) in order to find the corresponding CNF or DNF encoding.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.num_elements-Tuple{BitCircuit}","page":"LogicCircuits","title":"LogicCircuits.num_elements","text":"Number of elements (conjunctions) in layer or bit circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.or-Tuple{Bdd, Bdd}","page":"LogicCircuits","title":"LogicCircuits.or","text":"Returns a disjunction over the given boolean functions.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.or_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.or_nodes","text":"Get the list of or nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.pos_literals-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:LogicCircuit","page":"LogicCircuits","title":"LogicCircuits.pos_literals","text":"Get a sequence of positive literals\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.postorder-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.postorder","text":"Returns a Vector{Bdd} containing all nodes in α in post-order.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prime-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.prime","text":"Get the prime, that is, the first conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.print_conjunction-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.print_conjunction","text":"Pretty print a conjunction of literals BDD.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.print_nf-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.print_nf","text":"Pretty print BDD as a normal form (CNF or DNF).\n\nCaution: may exponentially explode.\n\nAlternatively, pretty prints using the given glyphs (default ∧, ∨ and ¬).\n\nϕ = (1 ∧ ¬2) ∨ (2 ∧ 3)\nprint_nf(α; out = false)\n\nϕ = (1 ∧ ¬2) ∨ (2 ∧ 3)\nprint_nf(α; out = false, which = \"dnf\", glyphs = ['+', '*', '-'])\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prob_equiv-Tuple{LogicCircuit, LogicCircuit, Int64}","page":"LogicCircuits","title":"LogicCircuits.prob_equiv","text":"Check equivalence using probabilistic equivalence checking. Note that this implentation may not have any formal guarantees as such.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.prob_equiv_signature","page":"LogicCircuits","title":"LogicCircuits.prob_equiv_signature","text":"prob_equiv_signature(circuit::LogicCircuit, k::Int)::Dict{Union{Var,Node},Signature}\n\nGet a signature for each node using probabilistic equivalence checking. Note that this implentation may not have any formal guarantees as such.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.process_mnist","page":"LogicCircuits","title":"LogicCircuits.process_mnist","text":"Processes the mnist dataset using the MNIST object from MLDataSets package MLDS_MNIST = the MNIST from MLDataSets labeled = whether to return the lables\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.propagate_constants-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.propagate_constants","text":"propagate_constants(root::Node)\n\nRemove all constant leafs from the circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.random_split-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.random_split","text":"Randomly picking egde and variable from candidates\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.reduce!-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.reduce!","text":"Reduce a Bdd rooted at α inplace, removing duplicate nodes and redundant sub-trees. Returns canonical representation of α.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.replace_node-Tuple{Node, Node, Node}","page":"LogicCircuits","title":"LogicCircuits.replace_node","text":"Replace node old with node new in circuit root\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.respects_vtree-Tuple{LogicCircuit, Vtree}","page":"LogicCircuits","title":"LogicCircuits.respects_vtree","text":"Does the circuit respect the given vtree? This function allows for constants in conjunctions, but only when a vtree node can be found where the left and right conjunct can be assigned to the left and right vtree.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.restrict-Union{Tuple{T}, Tuple{Bdd, Dict{T, Bool}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.restrict","text":"Returns a new reduced Bdd restricted to instantiation X.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.restrict_step-Tuple{Bdd, AbstractArray{Bool, N} where N, Dict{Int64, Bdd}}","page":"LogicCircuits","title":"LogicCircuits.restrict_step","text":"Returns a new Bdd restricted to instantiation X.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.restrict_step-Union{Tuple{T}, Tuple{Bdd, Dict{T, Bool}, Dict{Int64, Bdd}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.restrict_step","text":"Returns a new Bdd restricted to instantiation X.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sat_prob","page":"LogicCircuits","title":"LogicCircuits.sat_prob","text":"sat_prob(root::LogicCircuit; varprob::Function)::Rational{BigInt}\n\nGet the probability that a random world satisties the circuit.  Probability of each variable is given by varprob Function which defauls to 1/2 for every variable.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies-Tuple{LogicCircuit, Vararg{Real, N} where N}","page":"LogicCircuits","title":"LogicCircuits.satisfies","text":"Evaluate satisfaction of the circuit bottom-up for a given input\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_all","page":"LogicCircuits","title":"LogicCircuits.satisfies_all","text":"Evaluate the circuit bottom-up for a given input and return the value of all nodes\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_flows","page":"LogicCircuits","title":"LogicCircuits.satisfies_flows","text":"Compute the value and flow of each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_flows_down","page":"LogicCircuits","title":"LogicCircuits.satisfies_flows_down","text":"When values of nodes have already been computed, do a downward pass computing the flows at each node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_flows_down_layers-Tuple{BitCircuit, CUDA.CuArray{T, 2, B} where {T, B}, CUDA.CuArray{T, 2, B} where {T, B}, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.satisfies_flows_down_layers","text":"Pass flows down the layers of a bit circuit on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_flows_down_layers-Tuple{BitCircuit, Matrix{T} where T, Matrix{T} where T, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.satisfies_flows_down_layers","text":"Evaluate the layers of a bit circuit on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_flows_down_layers_cuda-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Nothing}","page":"LogicCircuits","title":"LogicCircuits.satisfies_flows_down_layers_cuda","text":"CUDA kernel for passing flows down circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_layers-Tuple{BitCircuit, CUDA.CuArray{T, 2, B} where {T, B}}","page":"LogicCircuits","title":"LogicCircuits.satisfies_layers","text":"Evaluate the layers of a bit circuit on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_layers-Tuple{BitCircuit, Matrix{T} where T}","page":"LogicCircuits","title":"LogicCircuits.satisfies_layers","text":"Evaluate the layers of a bit circuit on the CPU (SIMD & multi-threaded)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.satisfies_layers_cuda-NTuple{4, Any}","page":"LogicCircuits","title":"LogicCircuits.satisfies_layers_cuda","text":"CUDA kernel for circuit evaluation\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.save_bdd-Tuple{Bdd, String}","page":"LogicCircuits","title":"LogicCircuits.save_bdd","text":"Saves a BDD as a file.\n\nSupported file formats:\n\nCNF (.cnf);\nDNF (.dnf);\nBDD (.bdd).\n\nTo save as any of these file formats, simply set the filename with the desired extension.\n\nKeyword arguments are passed down to the open function.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.save_bdd_-Tuple{Bdd, String}","page":"LogicCircuits","title":"LogicCircuits.save_bdd_","text":"Save as BDD. Use the save_bdd function instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.save_cnf-Tuple{Bdd, String}","page":"LogicCircuits","title":"LogicCircuits.save_cnf","text":"Save as CNF. Use the save function instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.save_dnf-Tuple{Bdd, String}","page":"LogicCircuits","title":"LogicCircuits.save_dnf","text":"Save as DNF. Use the save function instead.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.scope-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.scope","text":"Returns all variables in this formula as a Vector{Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.scopeset-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.scopeset","text":"Returns all variables in this formula as a Set{Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_mgr_for-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.sdd_mgr_for","text":"Obtain an SDD manager that can support compiling the given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_num_nodes-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sdd_num_nodes","text":"Count the number of decision nodes in the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_num_nodes_leafs-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sdd_num_nodes_leafs","text":"Count the number of decision and leaf nodes in the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sdd_size-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sdd_size","text":"Count the number of elements in the decision nodes of the SDD\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.shallowhash","page":"LogicCircuits","title":"LogicCircuits.shallowhash","text":"Returns a shallow hash for the given node (not BDD as a whole).\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.shannon!-Union{Tuple{T}, Tuple{Bdd, Union{Set{T}, AbstractVector{T}}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.shannon!","text":"Performs Shannon's Decomposition on the Bdd α, given a set of variables to isolate. Any decomposition that results in a ⊥ is discarded.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.shannon-Tuple{Bdd, Integer}","page":"LogicCircuits","title":"LogicCircuits.shannon","text":"Performs Shannon's Decomposition on the Bdd α, given a variable to isolate.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.shannon-Union{Tuple{T}, Tuple{Bdd, Union{Set{T}, AbstractVector{T}}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.shannon","text":"Performs Shannon's Decomposition on the Bdd α, given a set of variables to isolate.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sibling-Tuple{Any, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.sibling","text":"Get the other child of a parent element\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.smooth","text":"smooth(root::Node)::Node\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth-Tuple{Sdd}","page":"LogicCircuits","title":"LogicCircuits.smooth","text":"Smooth an sdd to a StructLogicCircuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth-Tuple{StructLogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.smooth","text":"smooth(root::StructLogicCircuit)::StructLogicCircuit\n\nCreate an equivalent smooth circuit from the given circuit.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth_node-Tuple{Node, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.smooth_node","text":"smooth_node(node::Node, missing_scope, lit_nodes)\n\nReturn a smooth version of the node where  the missing_scope variables are added to the scope, using literals from lit_nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.smooth_node-Tuple{StructLogicCircuit, Any, Any, Any}","page":"LogicCircuits","title":"LogicCircuits.smooth_node","text":"smooth_node(node::StructLogicCircuit, parent_scope, scope, lit_nodes)\n\nReturn a smooth version of the node where  the are added to the scope by filling the gap in vtrees, using literals from lit_nodes\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.split_candidates-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.split_candidates","text":"split_candidates(circuit::Node)::Tuple{Vector{Tuple{Node, Node}}, Dict{Node, BitSet}}\n\nReturn the edges and variables which can be splited on\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.split_step-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.split_step","text":"Split step\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.standardize_circuit-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.standardize_circuit","text":"Standardize the circuit:\n\nChildren of or nodes are and nodes.\nChildren of and nodes are or nodes.\nEach and node has exactly two children.\n\nNote: for circuits with parameters this function will not keep the       parameters equavalent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.struct_learn-Tuple{Node}","page":"LogicCircuits","title":"LogicCircuits.struct_learn","text":"Structure learning manager\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.sub-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.sub","text":"Get the sub, that is, the second and last conjunct\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.terminal-Tuple{Bool}","page":"LogicCircuits","title":"LogicCircuits.terminal","text":"Returns a new terminal node of given boolean value.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.to_int-Tuple{Bdd}","page":"LogicCircuits","title":"LogicCircuits.to_int","text":"Returns 0 if x is not a literal; else returns an integer representation of x.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.to_lit-Union{Tuple{Bdd}, Tuple{T}, Tuple{Bdd, Type{T}}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.to_lit","text":"Returns α as an integer literal. Assumes α is a leaf node.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.tree_formula_string-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.tree_formula_string","text":"Get the formula of a given circuit as a string, expanding the formula into a tree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.twenty_datasets-Tuple{Any}","page":"LogicCircuits","title":"LogicCircuits.twenty_datasets","text":"train, valid, test = twenty_datasets(name)\n\nLoad a given dataset from the density estimation datasets. Automatically downloads the files as julia Artifacts.  See https://github.com/UCLA-StarAI/Density-Estimation-Datasets for a list of avaialble datasets.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.unique⋁-Tuple{Vector{LogicCircuits.Element}, LogicCircuits.SddMgrInnerNode}","page":"LogicCircuits","title":"LogicCircuits.unique⋁","text":"Construct a unique decision gate for the given vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.valuations-Union{Tuple{Union{Set{T}, UnitRange{T}, AbstractVector{T}}}, Tuple{T}} where T<:Integer","page":"LogicCircuits","title":"LogicCircuits.valuations","text":"Compute all possible valuations of scope V.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable","page":"LogicCircuits","title":"LogicCircuits.variable","text":"Get the variable in a vtree leaf\n\n\n\n\n\n","category":"function"},{"location":"api/internals/logiccircuits/#LogicCircuits.variable-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.variable","text":"Get the logical variable in a given literal leaf node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset-Tuple{Vtree, Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset","text":"Are the variables in n contained in the variables in m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_left-Tuple{Vtree, Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset_left","text":"Are the variables in n contained in the left branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.varsubset_right-Tuple{Vtree, Vtree}","page":"LogicCircuits","title":"LogicCircuits.varsubset_right","text":"Are the variables in n contained in the right branch of m?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.vtree-Tuple{StructLogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.vtree","text":"Get the vtree corresponding to the argument\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.vtree_safe-Tuple{PlainStructLogicInnerNode}","page":"LogicCircuits","title":"LogicCircuits.vtree_safe","text":"Get the vtree corresponding to the argument, or nothing if the node has no vtree\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋀_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.⋀_nodes","text":"Get the list of conjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/logiccircuits/#LogicCircuits.⋁_nodes-Tuple{LogicCircuit}","page":"LogicCircuits","title":"LogicCircuits.⋁_nodes","text":"Get the list of disjunction nodes in a given circuit\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#api-internal-utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/internals/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]","category":"page"},{"location":"api/internals/utils/#LogicCircuits.Utils","page":"Utils","title":"LogicCircuits.Utils","text":"Module with general utilities and missing standard library features  that could be useful in any Julia project\n\n\n\n\n\n","category":"module"},{"location":"api/internals/utils/#LogicCircuits.Utils.AbstractBitVector","page":"Utils","title":"LogicCircuits.Utils.AbstractBitVector","text":"Retro-fitted super type of all bit vectors\n\n\n\n\n\n","category":"constant"},{"location":"api/internals/utils/#LogicCircuits.Utils.CuBitVector","page":"Utils","title":"LogicCircuits.Utils.CuBitVector","text":"Custom CUDA version of BitVector (lacking lots of functionality, just a container for now).\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Dag","page":"Utils","title":"LogicCircuits.Utils.Dag","text":"A node in a directed acyclic graph (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Inner","page":"Utils","title":"LogicCircuits.Utils.Inner","text":"The trait of inner nodes (nodes that have children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Leaf","page":"Utils","title":"LogicCircuits.Utils.Leaf","text":"The trait of leaf nodes (nodes without children)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Lit","page":"Utils","title":"LogicCircuits.Utils.Lit","text":"Literals are represented as 32-bit signed integers. Positive literals are positive integers identical to their variable. Negative literals are their negations. Integer 0 should not be used to represent literals.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Node","page":"Utils","title":"LogicCircuits.Utils.Node","text":"A node in a directed graph. This type hierarchy is organized according  to the type of graph the node is part of.\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"A trait hierarchy denoting types of Dag nodes NodeType defines an orthogonal type hierarchy of node types, so we can dispatch on node type regardless of the graph type. See @ref{https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1}\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.NodeType-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.NodeType","text":"Get the node type trait of the given Node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.Tree","page":"Utils","title":"LogicCircuits.Utils.Tree","text":"A node in a tree (of which it is the root)\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#LogicCircuits.Utils.Var","page":"Utils","title":"LogicCircuits.Utils.Var","text":"Variables are represented as 32-bit unsigned integers\n\n\n\n\n\n","category":"type"},{"location":"api/internals/utils/#Base.eltype-Tuple{DataFrames.DataFrame}","page":"Utils","title":"Base.eltype","text":"Find a type that can capture all column values\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.filter-Union{Tuple{T}, Tuple{Function, Dag}, Tuple{Function, Dag, Any}, Tuple{Function, Dag, Any, Type{T}}} where T","page":"Utils","title":"Base.filter","text":"Retrieve list of nodes in graph matching predicate p\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.foreach","page":"Utils","title":"Base.foreach","text":"Apply a function to each node in a graph, bottom up\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#Base.in","page":"Utils","title":"Base.in","text":"Is the node contained in the Dag?\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#Base.isdisjoint-Tuple{AbstractSet, AbstractSet, AbstractSet, Vararg{AbstractSet, N} where N}","page":"Utils","title":"Base.isdisjoint","text":"Are the given sets disjoint (no shared elements)?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#Base.parent-Tuple{Tree}","page":"Utils","title":"Base.parent","text":"Get the parent of a given tree node (or nothing if the node is root)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#DataFrames.groupby-Union{Tuple{E}, Tuple{Function, Union{Set{E}, Vector{E}}}} where E","page":"Utils","title":"DataFrames.groupby","text":"Group the elements of list by their values according to function f\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogExpFunctions.logsumexp-Tuple{AbstractArray, Any}","page":"Utils","title":"LogExpFunctions.logsumexp","text":"Marginalize out dimensions dims from log-probability tensor\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.always-Union{Tuple{T}, Tuple{Type{T}, Vararg{Int64, N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.always","text":"An array of 100% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.bagging_dataset-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.bagging_dataset","text":"Returns an array of DataFrames where each DataFrame is randomly sampled from the original dataset data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.batch","page":"Utils","title":"LogicCircuits.Utils.batch","text":"Create mini-batches\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.batch_size-Tuple{Vector{DataFrames.DataFrame}}","page":"Utils","title":"LogicCircuits.Utils.batch_size","text":"Batch size of the dataset\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.bits_per_pixel-Tuple{Any, Any}","page":"Utils","title":"LogicCircuits.Utils.bits_per_pixel","text":"Normalize the given log-likelihood as bits per pixel in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.children","page":"Utils","title":"LogicCircuits.Utils.children","text":"Get the children of a given inner node\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.chunks-Tuple{AbstractBitVector}","page":"Utils","title":"LogicCircuits.Utils.chunks","text":"Retrieve chunks of bit vector\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.depth-Tuple{Tree, Function}","page":"Utils","title":"LogicCircuits.Utils.depth","text":"Compute the length of the path from a tree node to the leaf following the branching function\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.eachcol_unweighted-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.eachcol_unweighted","text":"Iterate over columns, excluding the sample weight column\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.example-Tuple{DataFrames.DataFrame, Any}","page":"Utils","title":"LogicCircuits.Utils.example","text":"Get the ith example\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.feature_values-Tuple{DataFrames.DataFrame, Any}","page":"Utils","title":"LogicCircuits.Utils.feature_values","text":"Get the ith feature values\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.find_inode-Tuple{Any, Any, Function}","page":"Utils","title":"LogicCircuits.Utils.find_inode","text":"Find a binary inner node that has left in its left subtree and right in its right subtree. Supports nothing as a catch-all for either left or right. Returns nothing if no such node exists.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.find_leaf-Tuple{Tree, Function}","page":"Utils","title":"LogicCircuits.Utils.find_leaf","text":"Find the leaf in the tree by follwing the branching function\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup-Union{Tuple{T}, Tuple{Dag, Function, Function, Type{T}}, Tuple{Dag, Function, Function, Type{T}, Nothing}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup","text":"foldup(node::Dag, \n    f_leaf::Function, \n    f_inner::Function, \n    ::Type{T})::T where {T}\n\nCompute a function bottom-up on the graph.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner as a function on the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foldup_aggregate-Union{Tuple{T}, Tuple{Dag, Function, Function, Type{T}}, Tuple{Dag, Function, Function, Type{T}, Nothing}} where T","page":"Utils","title":"LogicCircuits.Utils.foldup_aggregate","text":"Compute a function bottom-up on the circuit.  f_leaf is called on leaf nodes, and f_inner is called on inner nodes. Values of type T are passed up the circuit and given to f_inner in aggregate  as a vector from the children.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.foreach_down-Tuple{Function, Dag}","page":"Utils","title":"LogicCircuits.Utils.foreach_down","text":"Apply a function to each node in a graph, top down\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.fully_factorized_log_likelihood-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.fully_factorized_log_likelihood","text":"Computer the per-example log-likelihood of a fully factorized ML model on Bool data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.get_bit-Tuple{Any, Any}","page":"Utils","title":"LogicCircuits.Utils.get_bit","text":"Retrieve the jth bit from a BitVector chunk\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.get_weights-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.get_weights","text":"Get the weights from a weighted dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.has_children","text":"Does the node have children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.has_parent-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.has_parent","text":"Does the node have a parent?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.impute-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.impute","text":"Return a copy of Imputed values of X  (potentially statistics from another DataFrame)\n\nFor example, to impute using same DataFrame:\n\nimpute(X; method=:median)\n\nIf you want to use another DataFrame to provide imputation statistics:\n\nimpute(test_x, train_x; method=:mean)\n\nSupported methods are :median, :mean, :one, :zero\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.init_array-Union{Tuple{T}, Tuple{Type{T}, Vararg{Int64, N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.init_array","text":"An array of undetermined values (fast) for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.innernodes","page":"Utils","title":"LogicCircuits.Utils.innernodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.inode_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.inode_stats","text":"Give count of types and fan-ins of inner nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.inodes","page":"Utils","title":"LogicCircuits.Utils.inodes","text":"Get the list of inner nodes in a given graph\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.isbatched-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.isbatched","text":"Is the dataset batched?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isbinarydata-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.isbinarydata","text":"Is the dataset binary?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.iscomplete-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.iscomplete","text":"Is the data complete (no missing values)?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.iscomplete_col-Tuple{AbstractVector{Bool}}","page":"Utils","title":"LogicCircuits.Utils.iscomplete_col","text":"Is the data column complete (no missing values)?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isequal_local-Tuple{Tree, Tree}","page":"Utils","title":"LogicCircuits.Utils.isequal_local","text":"Is one node equal to another locally, ignoring children?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isfpdata-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.isfpdata","text":"Is the dataset consisting of floating point data?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isgpu-Tuple{Union{BitArray, Array}}","page":"Utils","title":"LogicCircuits.Utils.isgpu","text":"Check whether data resides on the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isinner-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isinner","text":"Is the node an Inner node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isleaf-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.isleaf","text":"Is the node a leaf node?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isroot-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.isroot","text":"Is the node the root of its tree?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.issomething-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.issomething","text":"Is the argument not nothing?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.isweighted-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.isweighted","text":"Is the dataset weighted?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.label_nodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.label_nodes","text":"Assign an integer label to each circuit node, bottom up, starting at 1\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lca-Tuple{Tree, Tree, Function}","page":"Utils","title":"LogicCircuits.Utils.lca","text":"Find the least common ancestor. Assumes the Tree has access to a parent.  A given descends_from function is required to quickly check whether a node is an ancestor.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leaf_stats-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.leaf_stats","text":"Give count of types of leaf nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.leafnodes","page":"Utils","title":"LogicCircuits.Utils.leafnodes","text":"Get the list of leaf nodes in a given graph\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.left_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.left_most_descendent","text":"Return the left-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.linearize-Union{Tuple{Dag}, Tuple{T}, Tuple{Dag, Type{T}}, Tuple{Dag, Type{T}, Any}} where T","page":"Utils","title":"LogicCircuits.Utils.linearize","text":"Order the Dag's nodes bottom-up in a list (with optional element type)\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.lit2var-Tuple{Int32}","page":"Utils","title":"LogicCircuits.Utils.lit2var","text":"Convert a literal its variable, removing the sign of the literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.ll_per_example-Tuple{Any, Any}","page":"Utils","title":"LogicCircuits.Utils.ll_per_example","text":"Normalize the given log-likelihood by the number of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.make_missing_mcar-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.make_missing_mcar","text":"make_missing_mcar(d::DataFrame; keep_prob::Float64=0.8)\n\nReturns a copy of dataframe with making some features missing as MCAR, with keep_prob as probability of keeping each feature.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.map_values-Union{Tuple{K}, Tuple{Function, AbstractDict{K, V} where V, Type}} where K","page":"Utils","title":"LogicCircuits.Utils.map_values","text":"Map the values in the dictionary, retaining the same keys\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.marginal_prob-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.marginal_prob","text":"Compute the marginal prob of each feature in a binary dataset.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.never-Union{Tuple{T}, Tuple{Type{T}, Vararg{Int64, N} where N}} where T<:Number","page":"Utils","title":"LogicCircuits.Utils.never","text":"An array of 0% probabilities for the given element type\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.node_stats-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.node_stats","text":"Give count of types and fan-ins of all nodes in the graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.noop-Tuple","page":"Utils","title":"LogicCircuits.Utils.noop","text":"Function that does nothing\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_children-Tuple{Node}","page":"Utils","title":"LogicCircuits.Utils.num_children","text":"Get the number of children of a given inner node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_chunks-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_chunks","text":"For binary complete data, how many UInt64 bit strings are needed to store one feature?\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_edges","page":"Utils","title":"LogicCircuits.Utils.num_edges","text":"Number of edges in the Dag\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_examples-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_examples","text":"num_examples(df::DataFrame)\n\nNumber of examples in data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_features-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.num_features","text":"num_features(df::DataFrame)\n\nNumber of features in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_innernodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_innernodes","text":"Count the number of inner nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_leafnodes-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.num_leafnodes","text":"Count the number of leaf nodes in a given graph\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_nodes","page":"Utils","title":"LogicCircuits.Utils.num_nodes","text":"num_nodes(node::Dag)\n\nCount the number of nodes in the Dag\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.num_variables-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.num_variables","text":"Number of variables in the data structure\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.order_asc-Tuple{Any, Any}","page":"Utils","title":"LogicCircuits.Utils.order_asc","text":"Order the arguments in a tuple in ascending order\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.print_tree","page":"Utils","title":"LogicCircuits.Utils.print_tree","text":"Print the given tree\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.pushrand!-Tuple{AbstractVector{var\"#s2\"} where var\"#s2\", Any}","page":"Utils","title":"LogicCircuits.Utils.pushrand!","text":"Push element into random position in vectorv\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.random_sample","page":"Utils","title":"LogicCircuits.Utils.random_sample","text":"Randomly draw samples from the dataset with replacement\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.right_most_descendent-Tuple{Dag}","page":"Utils","title":"LogicCircuits.Utils.right_most_descendent","text":"Return the right-most descendent.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.root-Tuple{Tree}","page":"Utils","title":"LogicCircuits.Utils.root","text":"Get the root of the given tree node\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.same_device-Tuple{Any, Any}","page":"Utils","title":"LogicCircuits.Utils.same_device","text":"Ensure that x resides on the same device as data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.shuffle_examples-Tuple{Any}","page":"Utils","title":"LogicCircuits.Utils.shuffle_examples","text":"shuffle_examples(df::DataFrame)\n\nShuffle the examples in the data\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.similar!-Union{Tuple{A}, Tuple{Any, Type{A}, Vararg{Any, N} where N}} where A<:AbstractArray","page":"Utils","title":"LogicCircuits.Utils.similar!","text":"Reuse a given array if it has the right type and size, otherwise make a new one\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.soften","page":"Utils","title":"LogicCircuits.Utils.soften","text":"Turn binary data into floating point data close to 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.split_sample_weights-Tuple{DataFrames.DataFrame}","page":"Utils","title":"LogicCircuits.Utils.split_sample_weights","text":"Split a weighted dataset into unweighted dataset  and its corresponding weights.\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.subseteq_fast-Tuple{BitSet, BitSet}","page":"Utils","title":"LogicCircuits.Utils.subseteq_fast","text":"Replacement for BitSet.⊆ that does not allocate a new BitSet\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.threshold-Tuple{Any, Any, Any}","page":"Utils","title":"LogicCircuits.Utils.threshold","text":"Threshold a numeric dataset making it binary\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.to_cpu-Tuple{Union{Array, BitVector}}","page":"Utils","title":"LogicCircuits.Utils.to_cpu","text":"Move data to the CPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.to_gpu-Tuple{Union{CuBitVector, CUDA.CuArray}}","page":"Utils","title":"LogicCircuits.Utils.to_gpu","text":"Move data to the GPU\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_edges","page":"Utils","title":"LogicCircuits.Utils.tree_num_edges","text":"tree_num_edges(node::Dag)::BigInt\n\nCompute the number of edges in the tree-unfolding of the Dag. \n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.tree_num_nodes","page":"Utils","title":"LogicCircuits.Utils.tree_num_nodes","text":"tree_num_nodes(node::Dag)::BigInt\n\nCompute the number of nodes in of a tree-unfolding of the Dag. \n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.uniform-Tuple{Vararg{Int64, N} where N}","page":"Utils","title":"LogicCircuits.Utils.uniform","text":"An array of uniform probabilities\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.var2lit-Tuple{UInt32}","page":"Utils","title":"LogicCircuits.Utils.var2lit","text":"Convert a variable to the corresponding positive literal\n\n\n\n\n\n","category":"method"},{"location":"api/internals/utils/#LogicCircuits.Utils.variables","page":"Utils","title":"LogicCircuits.Utils.variables","text":"Get the BitSet of variables in the data structure\n\n\n\n\n\n","category":"function"},{"location":"api/internals/utils/#LogicCircuits.Utils.weigh_samples-Tuple{DataFrames.DataFrame, Any}","page":"Utils","title":"LogicCircuits.Utils.weigh_samples","text":"Create a weighted copy of the data set\n\n\n\n\n\n","category":"method"},{"location":"manual/properties/#man-structural-properties","page":"Structural Properties","title":"Structural Properties","text":"","category":"section"},{"location":"manual/properties/#Smoothness","page":"Structural Properties","title":"Smoothness","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same set of variables. ","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To checks whether a circuit is smooth (issmooth):","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\");\nissmooth(lc)","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"As we see the circuit is not smooth. We can smooth the circuit using smooth:","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"smoothed_lc = smooth(lc)\nissmooth(smoothed_lc)","category":"page"},{"location":"manual/properties/#Determinism","page":"Structural Properties","title":"Determinism","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is deterministic if each of its OR nodes are deterministic. An OR node is deterministic if for every possible assignment to the variables, at most one of the its children can be active (true).","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To check for determinism, you can use isdeterministic. Note that checking determinisim required use of a SAT solver, and in general it is not tractable for big circuits.","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\");\nisdeterministic(lc)","category":"page"},{"location":"manual/properties/#Decomposability","page":"Structural Properties","title":"Decomposability","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"A logic circuit is decomposable if each of its AND nodes are decomposable.  An AND node is decomposable if for each pair of children the set of variables they depend on is disjoint.","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"To checks whether a circuit is decomposable (isdecomposable):","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\")\nisdecomposable(lc)","category":"page"},{"location":"manual/properties/#Structured-Decomposability","page":"Structural Properties","title":"Structured Decomposability","text":"","category":"section"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"Structured decomposability is a stonger condition that decomposability. In addition of each AND node being decomposable, they have to decompose in a structured way which is determined by a vtree (variable tree). A vtree, is a binary tree where each leaf represents a variable and each internal node represents a way of decomposing the variables. ","category":"page"},{"location":"manual/properties/","page":"Structural Properties","title":"Structural Properties","text":"using LogicCircuits # hide\nlc = zoo_sdd(\"random.sdd\")\nvtree = zoo_vtree(\"random.vtree\");\nrespects_vtree(lc, vtree)","category":"page"},{"location":"manual/transformations/#man-tranformations","page":"Tranformations","title":"Tranformations","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"In this section, we go over definition of possible transformations and code snippets to use them LogicCircuits.jl. We will use the following circuit(s) in our examples.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"using LogicCircuits\nX1, X2, X3 = pos_literals(LogicCircuit, 3)\ncircuit = (X1 & (X2 | -X3)) | (-X1 & (-X2 | X3));\n\ntree_formula_string(circuit)","category":"page"},{"location":"manual/transformations/#Forgetting","page":"Tranformations","title":"Forgetting","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta, forgetting the variable X can be thought of as erasing (forgetting) what the formula says about variable X:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta ","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Forgeting is also equivalent to disjunction of different ways to condition on X. The possible values for X are the literals x or lnot x, so we have:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"exists X Delta = (Delta mid x) lor (Delta mid lnot x)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given a circuit you can use forget to forget a variable (or multiple variables). For example, let's forget X_1:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"f1 = forget(circuit, (i) -> (i == Var(1)));\n\ntree_formula_string(f1)","category":"page"},{"location":"manual/transformations/#Propagate-Constants","page":"Tranformations","title":"Propagate Constants","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Some circuits might have constants True or False in them. To remove the constants and simplifying the circuits we can use propagate_constants.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"f1_prop = propagate_constants(f1);\n\ntree_formula_string(f1_prop)","category":"page"},{"location":"manual/transformations/#Smoothing","page":"Tranformations","title":"Smoothing","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Smoothing is the act of converting a non-smooth circuit to a circuit representing the same formula that is smooth. A logic circuit is smooth if each of its OR nodes are smooth.  An OR node is smooth if all of its children mention the same variables.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given a non-smooth circuit we can smooth it, for example:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"nonsmooth_circuit = X1 | -X2\ntree_formula_string(nonsmooth_circuit)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"smooth_circuit = smooth(nonsmooth_circuit)\ntree_formula_string(smooth_circuit)","category":"page"},{"location":"manual/transformations/#Split","page":"Tranformations","title":"Split","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given the logical formula of the circuit Delta and a variable x, splitting would give us the following logical circuit:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"(Delta land x) lor (Delta land lnot x)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"c1 = |((X1 | -X1) & (X2 | -X2));\nc2, _ = split(c1, (c1, c1.children[1]), Var(1); depth = 2);\nplot(c1)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"plot(c2)","category":"page"},{"location":"manual/transformations/#Clone","page":"Tranformations","title":"Clone","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Clone an or node and redirect one of its parents to the new copy. See clone for more documentation.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"or = X1 | -X1\nand1, and2 = (&)(or), (&)(or)\nc1 = and1 | and2\nc2 = clone(c1, and1, and2, or)\nplot(c1)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"plot(c2)","category":"page"},{"location":"manual/transformations/#Merge","page":"Tranformations","title":"Merge","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Merges two circuits. See merge for more documentation.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"or1 = X1 | (-X1 & -X2)\nor2 = -X1 | -X2\nc1 = |(or1 & or2)\nc2 = merge(c1, or1, or2)\nplot(c1)","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"plot(c2)","category":"page"},{"location":"manual/transformations/#Standardize-Circuit","page":"Tranformations","title":"Standardize Circuit","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Standraizes a given circuit to make sure the following properties hold:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Children of or nodes are and nodes.\nChildren of and nodes are or nodes.\nEach and node has exactly two children.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"See standardize_circuit for more details. ","category":"page"},{"location":"manual/transformations/#Apply","page":"Tranformations","title":"Apply","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Given two logic circuits Delta_1, Delta_2, and a binary operation o the apply operation outputs a logic circuit representing:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 o Delta_2","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"Note that, in addition to representing the correct formula, the apply operation also wants to preserve the structural properites of the circuits such as  determinism and decomposability.","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"The major binary operations are conjunction (land), disjunction (lor), and XOR (oplus). There are 2^4 = 16 possible binary operations, 6 of which are trivial operations (such as always returning false or depending only on one of the circuits). The other 10 can be derived by combination of not operation (lnot) with the main 3 operations mentioned. The list of all possible non-trivial binary operations are below:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"    Delta_1 lor Delta_2 lnot Delta_1 lor Delta_2 lnot Delta_1 lor lnot Delta_2 \n    Delta_1 land Delta_2 lnot Delta_1 land Delta_2 lnot Delta_1 land lnot Delta_2 \n    Delta_1 oplus Delta_2 lnot (Delta_1 oplus Delta_2) ","category":"page"},{"location":"manual/transformations/#Misc","page":"Tranformations","title":"Misc","text":"","category":"section"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"The following are also useful circuit transformation:","category":"page"},{"location":"manual/transformations/","page":"Tranformations","title":"Tranformations","text":"deepcopy: Recursively create a copy circuit rooted at n to a certain depth depth.\nreplace_node: Replaces node old with node new in the circuit.\nsplit_candidates: Return a list of possible split candidates\nclone_candidates: Returns a list of possible clone candidates\nrandom_split: Randomly picking egde and variable from split candidates ","category":"page"},{"location":"#LogicCircuits.jl","page":"Home","title":"LogicCircuits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LogicCircuits.jl module provides a Julia implementation of tools to represent boolean formulas, operate on them, and ask queries about them.    ","category":"page"},{"location":"#What-are-Logic-Circuits?","page":"Home","title":"What are Logic Circuits?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each logic circuit represents a boolean formula.  Internally, they are structured as a DAG with leave nodes being constants (true, false) or literals (X, lnot X).  Internal nodes can be AND or OR nodes.  Note that negation can only be done at the leaves.  This representation of boolean formulas is also known as Negation Normal Form (NNF).  In general, we also want to enforce few other structural properties such as smoothness, determinism, decomposability to enable tractable logical reasoning. ","category":"page"},{"location":"#What-can-we-do-with-them?","page":"Home","title":"What can we do with them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given a logic circuit there are many questions that we can ask.  For example, we might want to see whether it is satisfiable (SAT),  how many different ways are there to satisfy it (model counting),  or check whether it is equivalent with another logic circuit.  We refer to these as queries.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On another front, we might want to operate on the logic circuits themselves.  For example, we might want to condition on a literal, forget a variable, conjoin or disjoin two circuits, or negate the circuit.  We refer to these tasks as transformations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, many of these tasks are intractable, however given different combinations of  properties on structure of logic circuits we can unlock different queries to become tractable.","category":"page"},{"location":"#Where-to-learn-more-about-them?","page":"Home","title":"Where to learn more about them?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the Manual section for more details on important concepts, and examples on how to use this module.","category":"page"},{"location":"manual/sdd/#man-sdd","page":"Sentential Decision Diagrams","title":"Sentential Decision Diagrams","text":"","category":"section"},{"location":"manual/sdd/","page":"Sentential Decision Diagrams","title":"Sentential Decision Diagrams","text":"note: Note\nUnder construction.","category":"page"}]
}
