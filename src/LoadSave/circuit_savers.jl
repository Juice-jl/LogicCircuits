export save_as_dot, save_circuit, save_as_sdd

#####################
# Save lines
#####################

function save_lines(name::String, lines::CircuitFormatLines)
    open(name, "w") do f
        for line in lines
            println(f, line)
        end
    end
end

#####################
# decompile for nodes
#####################

"Decompile for sdd circuit, used during saving of circuits to file" 
decompile(n::PlainStructLiteralNode, node2id, vtree2id)::UnweightedLiteralLine = 
    UnweightedLiteralLine(node2id[n], vtree2id[n.vtree], literal(n), false)

decompile(n::PlainStructConstantNode, node2id, _)::AnonymousConstantLine = 
    AnonymousConstantLine(node2id[n], constant(n), false)

decompile(n::PlainStruct⋁Node, node2id, vtree2id)::DecisionLine{SDDElement} = 
    DecisionLine(node2id[n], vtree2id[n.vtree], UInt32(num_children(n)), map(c -> make_element(c, node2id), children(n)))

make_element(n::PlainStruct⋀Node, node2id) = 
    SDDElement(node2id[n.children[1]],  node2id[n.children[2]])

make_element(_::StructLogicCircuit, _) = 
    error("Given circuit is not an SDD, its decision node elements are not conjunctions.")

# TODO: decompile for logical circuit to some file format

#####################
# build maping
#####################

function get_node2id(circuit::LogicCircuit, T::Type) 
    node2id = Dict{T, ID}()
    outnodes = filter(n -> !is⋀gate(n), circuit)
    sizehint!(node2id, length(outnodes))
    index = ID(0) # node id start from 0
    for n in outnodes
        node2id[n] = index
        index += ID(1)
    end
    node2id
end

function get_vtree2id(vtree::PlainVtree):: Dict{PlainVtree, ID}
    vtree2id = Dict{PlainVtree, ID}()
    sizehint!(vtree2id, length(ln))
    index = ID(0) # vtree id start from 0
    foreach(vtree) do n
        vtree2id[n] = index
        index += ID(1)
    end
    vtree2id
end

#####################
# saver for circuits
#####################

"Returns header for SDD file format"
function sdd_header()
    """
    c ids of sdd nodes start at 0
    c sdd nodes appear bottom-up, children before parents
    c
    c file syntax:
    c sdd count-of-sdd-nodes
    c F id-of-false-sdd-node
    c T id-of-true-sdd-node
    c L id-of-literal-sdd-node id-of-vtree literal
    c D id-of-decomposition-sdd-node id-of-vtree number-of-elements {id-of-prime id-of-sub}*
    c
    c File generated by Juice.jl
    c"""
end

"Save a SDD circuit to file"
function save_as_sdd(name::String, circuit::StructLogicCircuit, vtree::PlainVtree)
    #TODO no need to pass the vtree, we can infer it from origin?
    @assert endswith(name, ".sdd")
    node2id = get_node2id(circuit, StructLogicCircuit)
    vtree2id = get_vtree2id(vtree)
    formatlines = Vector{CircuitFormatLine}()
    append!(formatlines, parse_sdd_file(IOBuffer(sdd_header())))
    push!(formatlines, SddHeaderLine(num_nodes(circuit)))
    for n in filter(n -> !is⋀gate(n), circuit)
        push!(formatlines, decompile(n, node2id, vtree2id))
    end
    save_lines(name, formatlines)
end

"Save a circuit to file"
save_circuit(name::String, circuit::StructLogicCircuit, vtree::PlainVtree) =
    save_as_sdd(name, circuit, vtree)

"Rank nodes in the same layer left to right"
function get_nodes_level(circuit::LogicCircuit)
    levels = Vector{Vector{Node}}()
    current = Vector{Node}()
    next = Vector{Node}()

    push!(next, circuit)
    push!(levels, Base.copy(next))
    while !isempty(next)
        current, next = next, current
        while !isempty(current)
            n = popfirst!(current)
            if isinner(n)
                for c in children(n)
                    if !(c in next) push!(next, c); end
                end
            end
        end
        push!(levels, Base.copy(next))
    end

    return levels
end

"Save logic circuit to .dot file"
function save_as_dot(circuit::LogicCircuit, file::String)
    circuit_nodes = linearize(circuit)
    node_cache = Dict{LogicCircuit, Int64}()
    for (i, n) in enumerate(circuit_nodes)
        node_cache[n] = i
    end

    levels = get_nodes_level(circuit)

    f = open(file, "w")
    write(f,"digraph Circuit {\nsplines=false\nedge[arrowhead=\"none\",fontsize=6]\n")

    for level in levels
        if length(level) > 1
            write(f,"{rank=\"same\";newrank=\"true\";rankdir=\"LR\";")
            rank = ""
            foreach(x->rank*="$(node_cache[x])->",level)
            rank = rank[1:end-2]
            write(f, rank)
            write(f,"[style=invis]}\n")
        end
    end

    for n in reverse(circuit_nodes)
        if is⋀gate(n)
            write(f, "$(node_cache[n]) [label=\"*$(node_cache[n])\"]\n")
        elseif is⋁gate(n)
            write(f, "$(node_cache[n]) [label=\"+$(node_cache[n])\"]\n")
        elseif isliteralgate(n) && ispositive(n)
            write(f, "$(node_cache[n]) [label=\"+$(variable(n))\"]\n")
        elseif isliteralgate(n)  && isnegative(n)
            write(f, "$(node_cache[n]) [label=\"-$(variable(n))\"]\n")
        elseif isfalse(n)
            write(f, "$(node_cache[n]) [label=\"F\"]\n")
        elseif istrue(n)
            write(f, "$(node_cache[n]) [label=\"T\"]\n")
        else
            throw("unknown node type")
        end
    end

    for n in reverse(circuit_nodes)
        if isinnergate(n)
            for c in children(n)
                write(f, "$(node_cache[n]) -> $(node_cache[c])\n")
            end
        end
    end

    write(f, "}\n")
    flush(f)
    close(f)
end
